{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to <code>iqtools</code>","text":"<p>Collection of code for working with offline complex valued time series data (inphase and quadrature or IQ Data) with numpy written for Python3.</p>"},{"location":"#installation","title":"Installation","text":"<p>Clone the repository or download the source from GitHUB. Then use <code>pip</code> for installing and uninstalling <code>iqtools</code>.</p> <pre><code>pip install -r requirements.txt\npip install .\n</code></pre> <p>If you like to use <code>iqtools</code> with ROOT features within PyROOT, please make sure you have a proper installation of ROOT and PyROOT in your python environment. Please refer to the web site of PyROOT. An alternative, much easier way is to install ROOT using <code>conda-forge</code> as described here or here.</p>"},{"location":"#quick-usage","title":"Quick usage","text":"<p><code>iqtools</code> is a library that can be embedded in data analysis projects. It also has a GUI and CLI for quick access or conversions, so it can be run as a command line program for processing data file as well. Type:</p> <pre><code>iqtools --help\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>For more information please refer to the documentation page.</p>"},{"location":"#citation-for-publications","title":"Citation for publications","text":"<p>If you are using this code in your publications, please refer to DOI:10.5281/zenodo.7615693 for citation, or cite as:</p> <p> Shahab Sanjari. (2023). iqtools: Collection of code for working with offline complex valued time series data in Python. Zenodo. https://doi.org/10.5281/zenodo.7615693 </p>"},{"location":"examples/","title":"Examples","text":"<p>In case you need some data file to work through these examples you can take this one.</p>"},{"location":"examples/#example-histogram-using-matplotlib","title":"Example histogram using <code>matplotlib</code>","text":"<p><pre><code>from iqtools import *\n\nfilename = 'p_400_MeV_u_332_uA_0.tiq'\niq = get_iq_object(filename)\n\niq.read_samples(200*1024)\niq.method='fft'\nxx, yy, zz = iq.get_power_spectrogram(lframes=1024, nframes=200)\n\n# change font\nfont = {'family' : 'normal',\n        'weight' : 'bold',\n        'size'   : 12}\n\nplt.rc('font', **font)\n\n# reduce number of ticks\nplt.locator_params(axis='x', nbins=3)\n\nplot_spectrogram(xx, yy, zz, cen=iq.center, title=iq.file_basename, decimal_place=1, zzmin=0, zzmax=50000, cmap=cm.jet)\n</code></pre> </p> <p>You can use numpy slicing of indexes in order to plot a certain region</p> <pre><code>sly = slice(412, 512)\nslx = slice(84000,110000)\nplot_spectrogram(xx[sly,slx], yy[sly,slx], zz[sly,slx], ...)\n</code></pre>"},{"location":"examples/#interface-with-cern-root","title":"Interface with CERN ROOT","text":"<p><pre><code>from iqtools import *\nfrom ROOT import TCanvas, TFile\n%matplotlib inline\n\nfilename = 'p_400_MeV_u_332_uA_0.tiq'\niq = get_iq_object(filename)\n\niq.read_samples(200*1024)\niq.method='fft'\nxx, yy, zz = iq.get_power_spectrogram(lframes=1024, nframes=200)\n\nh3 = get_root_th2d(xx, yy, zz, name=filename, title=filename)\n\nff = TFile( f'{filename}.root', 'RECREATE' )\nh3.Write()\nh3.ProjectionX().Write()\nff.Close()\n\nc = TCanvas(filename,filename,800,600)\nc.Divide(1,2)\nc.cd(1)\nh3.Draw('zcol')\nc.cd(2)\nh3.ProjectionX().DrawClone()\nc.Draw()\n</code></pre> </p> <p>Also 1D spectra can be exported to ROOT histograms for later analysis in ROOT:</p> <pre><code>ff, pp, _ = iq.get_fft()\nwrite_spectrum_to_root(ff, pp, filename, center=iq.center, title='spectrum')\n</code></pre> <p>the resulting ROOT file will contain a histogram. Also time domain data can be written to a ROOT file:</p> <pre><code>write_timedata_to_root(iq)\n</code></pre>"},{"location":"examples/#spectrum-plot-over-time","title":"Spectrum plot over time","text":"<p>Example of spectrum plot over time (not to be confused with a spectrogram plot)</p> <pre><code>from iqtools import *\nfilename = 'cooler_off-2022.06.24.11.12.57.427.tiq'\niq = get_iq_object(filename)\nlframes = 1024\nnframes=3000\nfor ii in range(6):\n    sframes = ii * nframes\n    iq.read(nframes = nframes, lframes = lframes, sframes = sframes)\n    ff, pp, _ = iq.get_fft()\n    plot_spectrum(ff, pp / pp.max() + ii, title='Beam spectra vs time.')\n</code></pre> <p></p>"},{"location":"examples/#creating-a-synthetic-signal","title":"Creating a synthetic signal","text":"<p>You can create a synthetic signal like the following:</p> <p><pre><code>fs = 22050\nf = 400\ncenter = 133\nt, x = make_test_signal(400, 22050, noise=False, nharm=2)\nxbar , insph = make_analytical(x)\nwrite_signal_to_bin(xbar, 'results', fs=fs, center=center)\nwrite_signal_to_csv(xbar, 'results', fs=fs, center=center)\nplt.plot(t[:100], x[:100])\nplot_hilbert(xbar)\n</code></pre> </p> <p>The files with names <code>results.csv</code> and <code>results.bin</code> can now be read back into the code using <code>iqtools</code>.</p>"},{"location":"examples/#gnuradio-interface","title":"GNURadio interface","text":""},{"location":"examples/#reading-gnuradio-files","title":"Reading GNURadio files","text":"<p>If you have a flow graph in gnuradio and like to save files, you can use the file sink block and save data. Using <code>iqtools</code> you can then import the data as usual, except that you have to provide the sampling rate. You can also use the library interface or the command line interface to convert your data into complex64 (I and Q each 32-bit) for further use in GNU Radio. Here is an example to plot an spectrogram:</p> <pre><code>import iqtools\nfilename = 'file_from_gnuradio.bin'\niqdata = iqtools.GRData(filename, fs = 2.5e6, center=30e6)\niqdata.read_complete_file()\nxx, yy, zz = iqdata.get_power_spectrogram(nframes=2000, lframes=1024)\niqtools.plot_spectrogram(xx, yy, zz)\n</code></pre>"},{"location":"examples/#writing-gnuradio-files","title":"Writing GNURadio files","text":"<p>Convert data for further use in GNU Radio.</p> <pre><code>iqtools --verbose --lframes 1024 --nframes 1 --raw p_400_MeV_u_332_uA_0.tiq\n</code></pre> <p>The sampling rate and the center frequency will also be printed. Or within your program like:</p> <pre><code>from iqtools import *\nfilename = 'p_400_MeV_u_332_uA_0.tiq'\niq=TIQData(filename)\niq.read_samples(1024*100)\nwrite_signal_to_bin( iq.data_array, 'p_400_MeV_u_332_uA_0', fs=iq.fs, center = iq.center, write_header=False)\n</code></pre> <p>Later the file can be imported using a <code>File Source</code> block in GNU-Radio. Use a <code>Throttle</code> block with the sampling rate of the data.</p> <p> </p>"},{"location":"overview/","title":"Overview of <code>iqtools</code>","text":""},{"location":"overview/#introduction","title":"Introduction","text":"<p>IQ data are usually results of measurements of quantities in scientific research such as physics experiments or other related fields in science and engineering. These data are usually acquired using radio frequency data acquisition systems or software defined radios (SDR) involving one of the many methods of analog or digital Hilbert transformation for the creation of analytic signals, which in turn are easily processed in further stages. Applications include particle and fundamental physics, astrophysics, software defined radio and many more in science and engineering.</p> <p><code>iqtools</code> allows direct usage of class file and tools within own scrips or iPython Notebook sessions. The library offers an extendable structure for adding further methods e.g. in spectral analysis or non-linear time series analysis.</p>"},{"location":"overview/#code-components","title":"Code Components","text":"<p><code>iqtools</code> is a library, but it also comes with a CLI and a GUI. The library is constructed as follows:</p>"},{"location":"overview/#iqbase-class-and-its-sub-classes","title":"IQBase class and its sub classes","text":"<p>This class covers all required parameters to handle time domain IQ data and their representation in frequency domain. Cuts, slices etc. are also available. Also a set of windowing functions are available.</p>"},{"location":"overview/#filetype-specific-classes","title":"Filetype specific classes","text":"<p>There are several specific classes available for each file type, all sharing the common base.</p>"},{"location":"overview/#tools-and-plotters","title":"Tools and plotters","text":"<p>Two separate module includes several tools like plotters and input / output routines for convenience.</p>"},{"location":"overview/#supported-file-formats","title":"Supported file formats","text":""},{"location":"overview/#tektronix-binary-file-formats-iqt-tiq-xdat-and-r3f","title":"Tektronix\u00ae binary file formats *.IQT, *.TIQ, *.XDAT and *.R3F","text":"<p>Data format from different generations of real time spectrum analyzers, including the 3000, 5000 and also 600 USB analyzer series. In the tools section, there is also support for the *.specan data format which is the already converted trace format in the analyzer software.</p>"},{"location":"overview/#national-instruments-tdms","title":"National Instruments\u2122 *.TDMS","text":"<p>Data format used in NI's LabView\u2122. Based on the python library nptdms.</p>"},{"location":"overview/#tcap-dat-files","title":"TCAP *.DAT files","text":"<p>TCAP file format form the older HP E1430A systems. In this case, the header information is stored in a TXT file, while the data file is stored in blocks of 2GB sequentially. More information can be found in this PhD thesis.</p>"},{"location":"overview/#lecroy-584am-data-files","title":"LeCroy\u00ae 584AM Data files","text":"<p>Reading data files from this old oscilloscope is possible with its own class.</p>"},{"location":"overview/#audio-file-wav","title":"Audio file *.WAV","text":"<p>This data format is mostly useful for software defined radio applications. Left and right channels are treated as real and imaginary components respectively, file duration and sampling rate are determined automatically. Memory map is activated to avoid the whole file will be loaded in memory.</p>"},{"location":"overview/#raw-binary-bin-ascii-csv-and-txt","title":"Raw binary *.BIN, ASCII *.CSV and *.TXT","text":"<p>The binary files begin with a 32-bit integer for sampling rate, followed by a 32-bit float for the center frequency. The rest of the file contains real and imaginary parts each as a 32-bit floats. File size is automatically calculated. All data are little endian. The ASCII files are tab or space separated values with real and imaginary on every line. These data will later be treated as 32-bit floating point numbers. Lines beginning with # are considered as comments and are ignored. Here also the first line contains the a 32-bit integer for sampling rate, followed by a 32-bit float for the center frequency. Such files are used as a result of synthesis signals. See examples section for more information.</p>"},{"location":"overview/#gnu-radio-format","title":"GNU Radio format","text":"<p>You can read and write to files that originate from or need to be processed in GNU Radio. Please see examples section for more information.</p>"},{"location":"overview/#cern-root-format","title":"CERN ROOT format","text":"<p>ROOT is an extensive data analysis framework that is very popular in the physics community. <code>iqtools</code> has possibilities to interface with ROOT using the uproot library.  See examples section for more information.</p>"},{"location":"references/bindata/","title":"BINData","text":"<p>Class for IQ Data RAW formats</p> <p>xaratustrah@github Aug-2015</p>"},{"location":"references/bindata/#iqtools.bindata.BINData","title":"<code>BINData</code>","text":"<p>         Bases: <code>IQBase</code></p> Source code in <code>iqtools/bindata.py</code> <pre><code>class BINData(IQBase):\n    def __init__(self, filename):\n        super().__init__(filename)\n\n        # Additional fields in this subclass\n        self.date_time = time.ctime(os.path.getctime(self.filename))\n        self.center = 0.0\n        # each complex64 sample is 8 bytes on disk\n        self.nsamples_total = os.path.getsize(filename) / 8\n\n    def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n        Args:\n            nframes (int, optional): Number of frames to be read. Defaults to 10.\n            lframes (int, optional): Length of each frame. Defaults to 1024.\n            sframes (int, optional): Starting frame. Defaults to 0.\n        \"\"\"        \n        self.read_samples(nframes * lframes, offset=sframes * lframes)\n\n    def read_samples(self, nsamples, offset=0):\n\"\"\"Read samples. Requries the first value to be the header.\n        Please also check the function:\n            write_signal_to_bin\n        in the `tools`.\n\n        Args:\n            nsamples (int): Number of samples to read from file\n            offset (int, optional): _description_. Defaults to 0.\n\n        Raises:\n            ValueError: Raises if the requested number of samples is larger than available\n        \"\"\"        \n        if nsamples &gt; self.nsamples_total - offset:\n            raise ValueError(\n                'Requested number of samples is larger than the available {} samples.'.format(self.nsamples_total))\n\n        x = np.fromfile(self.filename, dtype=np.complex64)\n        self.fs = float(np.real(x[0]))\n        self.center = float(np.imag(x[0]))\n        all_data = x[1:]\n\n        self.data_array = all_data[offset:nsamples + offset]\n</code></pre>"},{"location":"references/bindata/#iqtools.bindata.BINData.read","title":"<code>read(nframes=10, lframes=1024, sframes=0)</code>","text":"<p>Read a section of the file.</p> <p>Parameters:</p> Name Type Description Default <code>nframes</code> <code>int</code> <p>Number of frames to be read. Defaults to 10.</p> <code>10</code> <code>lframes</code> <code>int</code> <p>Length of each frame. Defaults to 1024.</p> <code>1024</code> <code>sframes</code> <code>int</code> <p>Starting frame. Defaults to 0.</p> <code>0</code> Source code in <code>iqtools/bindata.py</code> <pre><code>def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n    Args:\n        nframes (int, optional): Number of frames to be read. Defaults to 10.\n        lframes (int, optional): Length of each frame. Defaults to 1024.\n        sframes (int, optional): Starting frame. Defaults to 0.\n    \"\"\"        \n    self.read_samples(nframes * lframes, offset=sframes * lframes)\n</code></pre>"},{"location":"references/bindata/#iqtools.bindata.BINData.read_samples","title":"<code>read_samples(nsamples, offset=0)</code>","text":"<p>Read samples. Requries the first value to be the header.</p> Please also check the function <p>write_signal_to_bin</p> <p>in the <code>tools</code>.</p> <p>Parameters:</p> Name Type Description Default <code>nsamples</code> <code>int</code> <p>Number of samples to read from file</p> required <code>offset</code> <code>int</code> <p>description. Defaults to 0.</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Raises if the requested number of samples is larger than available</p> Source code in <code>iqtools/bindata.py</code> <pre><code>def read_samples(self, nsamples, offset=0):\n\"\"\"Read samples. Requries the first value to be the header.\n    Please also check the function:\n        write_signal_to_bin\n    in the `tools`.\n\n    Args:\n        nsamples (int): Number of samples to read from file\n        offset (int, optional): _description_. Defaults to 0.\n\n    Raises:\n        ValueError: Raises if the requested number of samples is larger than available\n    \"\"\"        \n    if nsamples &gt; self.nsamples_total - offset:\n        raise ValueError(\n            'Requested number of samples is larger than the available {} samples.'.format(self.nsamples_total))\n\n    x = np.fromfile(self.filename, dtype=np.complex64)\n    self.fs = float(np.real(x[0]))\n    self.center = float(np.imag(x[0]))\n    all_data = x[1:]\n\n    self.data_array = all_data[offset:nsamples + offset]\n</code></pre>"},{"location":"references/csvdata/","title":"CSVData","text":"<p>Class for IQ Data CSV and TXT formats</p> <p>xaratustrah@github Aug-2015</p>"},{"location":"references/csvdata/#iqtools.csvdata.CSVData","title":"<code>CSVData</code>","text":"<p>         Bases: <code>IQBase</code></p> Source code in <code>iqtools/csvdata.py</code> <pre><code>class CSVData(IQBase):\n    def __init__(self, filename):\n        super().__init__(filename)\n\n        # Additional fields in this subclass\n        self.center = 0.0\n        self.date_time = time.ctime(os.path.getctime(self.filename))\n        self.nsamples_total = sum(1 for line in open(filename)) - 1\n\n    def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n        Args:\n            nframes (int, optional): Number of frames to be read. Defaults to 10.\n            lframes (int, optional): Length of each frame. Defaults to 1024.\n            sframes (int, optional): Starting frame. Defaults to 0.\n        \"\"\"        \n        self.read_samples(nframes * lframes, offset=sframes * lframes)\n\n    def read_samples(self, nsamples, offset=0):\n\"\"\"Read samples. Requries the first line to be the header.\n        Please also check the function:\n            write_signal_to_csv\n        in the `tools`.\n\n        Args:\n            nsamples (int): Number of samples to read from file\n            offset (int, optional): _description_. Defaults to 0.\n\n        Raises:\n            ValueError: Raises if the requested number of samples is larger than available\n        \"\"\"        \n\n        if nsamples &gt; self.nsamples_total - offset:\n            raise ValueError(\n                'Requested number of samples is larger than the available {} samples.'.format(self.nsamples_total))\n\n        x = np.genfromtxt(self.filename, dtype=np.float32, delimiter='|')\n        self.fs = x[0, 0]\n        self.center = x[0, 1]\n        all_data = x[1:, :]\n        all_data = all_data.view(np.complex64)[:, 0]\n\n        self.data_array = all_data[offset:nsamples + offset]\n</code></pre>"},{"location":"references/csvdata/#iqtools.csvdata.CSVData.read","title":"<code>read(nframes=10, lframes=1024, sframes=0)</code>","text":"<p>Read a section of the file.</p> <p>Parameters:</p> Name Type Description Default <code>nframes</code> <code>int</code> <p>Number of frames to be read. Defaults to 10.</p> <code>10</code> <code>lframes</code> <code>int</code> <p>Length of each frame. Defaults to 1024.</p> <code>1024</code> <code>sframes</code> <code>int</code> <p>Starting frame. Defaults to 0.</p> <code>0</code> Source code in <code>iqtools/csvdata.py</code> <pre><code>def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n    Args:\n        nframes (int, optional): Number of frames to be read. Defaults to 10.\n        lframes (int, optional): Length of each frame. Defaults to 1024.\n        sframes (int, optional): Starting frame. Defaults to 0.\n    \"\"\"        \n    self.read_samples(nframes * lframes, offset=sframes * lframes)\n</code></pre>"},{"location":"references/csvdata/#iqtools.csvdata.CSVData.read_samples","title":"<code>read_samples(nsamples, offset=0)</code>","text":"<p>Read samples. Requries the first line to be the header.</p> Please also check the function <p>write_signal_to_csv</p> <p>in the <code>tools</code>.</p> <p>Parameters:</p> Name Type Description Default <code>nsamples</code> <code>int</code> <p>Number of samples to read from file</p> required <code>offset</code> <code>int</code> <p>description. Defaults to 0.</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Raises if the requested number of samples is larger than available</p> Source code in <code>iqtools/csvdata.py</code> <pre><code>def read_samples(self, nsamples, offset=0):\n\"\"\"Read samples. Requries the first line to be the header.\n    Please also check the function:\n        write_signal_to_csv\n    in the `tools`.\n\n    Args:\n        nsamples (int): Number of samples to read from file\n        offset (int, optional): _description_. Defaults to 0.\n\n    Raises:\n        ValueError: Raises if the requested number of samples is larger than available\n    \"\"\"        \n\n    if nsamples &gt; self.nsamples_total - offset:\n        raise ValueError(\n            'Requested number of samples is larger than the available {} samples.'.format(self.nsamples_total))\n\n    x = np.genfromtxt(self.filename, dtype=np.float32, delimiter='|')\n    self.fs = x[0, 0]\n    self.center = x[0, 1]\n    all_data = x[1:, :]\n    all_data = all_data.view(np.complex64)[:, 0]\n\n    self.data_array = all_data[offset:nsamples + offset]\n</code></pre>"},{"location":"references/grdata/","title":"GRData","text":"<p>Class for IQ Data GNU Radio simple binary format reader</p> <p>xaratustrah@github Aug-2018</p>"},{"location":"references/grdata/#iqtools.grdata.GRData","title":"<code>GRData</code>","text":"<p>         Bases: <code>IQBase</code></p> Source code in <code>iqtools/grdata.py</code> <pre><code>class GRData(IQBase):\n    def __init__(self, filename, fs, center=0, date_time=\"\"):\n        super().__init__(filename)\n        # Additional fields in this subclass\n        self.date_time = date_time\n        self.center = center\n        # each complex64 sample is 8 bytes on disk\n        self.nsamples_total = os.path.getsize(filename) / 8\n\n    def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n        Args:\n            nframes (int, optional): Number of frames to be read. Defaults to 10.\n            lframes (int, optional): Length of each frame. Defaults to 1024.\n            sframes (int, optional): Starting frame. Defaults to 0.\n        \"\"\"        \n\n        self.read_samples(nframes * lframes, offset=sframes * lframes)\n</code></pre>"},{"location":"references/grdata/#iqtools.grdata.GRData.read","title":"<code>read(nframes=10, lframes=1024, sframes=0)</code>","text":"<p>Read a section of the file.</p> <p>Parameters:</p> Name Type Description Default <code>nframes</code> <code>int</code> <p>Number of frames to be read. Defaults to 10.</p> <code>10</code> <code>lframes</code> <code>int</code> <p>Length of each frame. Defaults to 1024.</p> <code>1024</code> <code>sframes</code> <code>int</code> <p>Starting frame. Defaults to 0.</p> <code>0</code> Source code in <code>iqtools/grdata.py</code> <pre><code>def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n    Args:\n        nframes (int, optional): Number of frames to be read. Defaults to 10.\n        lframes (int, optional): Length of each frame. Defaults to 1024.\n        sframes (int, optional): Starting frame. Defaults to 0.\n    \"\"\"        \n\n    self.read_samples(nframes * lframes, offset=sframes * lframes)\n</code></pre>"},{"location":"references/iqbase/","title":"IQBase","text":"<p>The base class for all other IQ Data</p> <p>xaratustrah@github Aug-2015</p>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase","title":"<code>IQBase</code>","text":"<p>         Bases: <code>object</code></p> Source code in <code>iqtools/iqbase.py</code> <pre><code>class IQBase(object):\n    # Abstract class\n    __metaclass__ = ABCMeta\n\n    def __init__(self, filename):\n\n        # fields required in all subclasses\n        # primary fileds\n\n        self.filename = filename\n        self.data_array = None\n        self.scale = 1\n        self.nsamples_total = 0\n        self.fs = 0.0\n\n        # secondary fileds\n        self.file_basename = os.path.basename(filename)\n        self.filename_wo_ext = os.path.splitext(filename)[0]\n        self.window = 'rectangular'\n        self.method = 'fft'\n\n    def __str__(self):\n        return self.dic2htmlstring(vars(self))\n\n    def dic2htmlstring(self, dic):\n\"\"\"Converts a dictionary to an HTML string\n\n        Args:\n            dic (dictionary): Dictionary of values\n\n        Returns:\n            (string): HTML String\n        \"\"\"        \n        outstr = ''\n        if 'filename' in dic:\n            outstr += '&lt;font size=\"4\" color=\"green\"&gt;File name:&lt;/font&gt; {} &lt;font size=\"4\" color=\"green\"&gt;&lt;/font&gt;&lt;br&gt;\\n'.format(\n                self.filename)\n        if 'nsamples_total' in dic:\n            outstr += '&lt;font size=\"4\" color=\"green\"&gt;Record length:&lt;/font&gt; {:.2e} &lt;font size=\"4\" color=\"green\"&gt;[s]&lt;/font&gt;&lt;br&gt;\\n'.format(\n                self.get_record_length())\n        if 'nsamples_total' in dic:\n            outstr += '&lt;font size=\"4\" color=\"green\"&gt;No. Samples:&lt;/font&gt; {} &lt;br&gt;\\n'.format(\n                self.nsamples_total)\n        if 'fs' in dic:\n            outstr += '&lt;font size=\"4\" color=\"green\"&gt;Sampling rate:&lt;/font&gt; {} &lt;font size=\"4\" color=\"green\"&gt;[sps]&lt;/font&gt;&lt;br&gt;\\n'.format(\n                self.fs)\n        if 'center' in dic:\n            outstr += '&lt;font size=\"4\" color=\"green\"&gt;Center freq.:&lt;/font&gt; {} &lt;font size=\"4\" color=\"green\"&gt;[Hz]&lt;/font&gt;&lt;br&gt;\\n'.format(\n                self.center)\n        if 'span' in dic:\n            outstr += '&lt;font size=\"4\" color=\"green\"&gt;Span:&lt;/font&gt; {} &lt;font size=\"4\" color=\"green\"&gt;[Hz]&lt;/font&gt;&lt;br&gt;\\n'.format(\n                self.span)\n        if 'acq_bw' in dic:\n            outstr += '&lt;font size=\"4\" color=\"green\"&gt;Acq. BW.:&lt;/font&gt; {} &lt;br&gt;\\n'.format(\n                self.acq_bw)\n        if 'rbw' in dic:\n            outstr += '&lt;font size=\"4\" color=\"green\"&gt;RBW:&lt;/font&gt; {} &lt;br&gt;\\n'.format(\n                self.rbw)\n        if 'rf_att' in dic:\n            outstr += '&lt;font size=\"4\" color=\"green\"&gt;RF Att.:&lt;/font&gt; {} &lt;br&gt;\\n'.format(\n                self.rf_att)\n        if 'date_time' in dic:\n            outstr += '&lt;font size=\"4\" color=\"green\"&gt;Date and Time:&lt;/font&gt; {} &lt;br&gt;\\n'.format(\n                self.date_time)\n            return outstr\n\n    def get_record_length(self):\n\"\"\"Returns the record length\n\n        Returns:\n            (float): record length\n        \"\"\"        \n        return self.nsamples_total / self.fs\n\n    @abstractmethod\n    def read(self, nframes, lframes, sframes):\n\"\"\"Abstract method\n        \"\"\"        \n        pass\n\n    @abstractmethod\n    def read_samples(self, nsamples, offset):\n\"\"\"Abstract method\n        \"\"\"        \n        pass\n\n    def get_window(self, n=None):\n\"\"\"Return a suitable windowing function for FFT\n\n        Args:\n            n (int, optional): Window length. Defaults to None.\n\n        Returns:\n            (ndarray): FFT Window\n        \"\"\"        \n        if not n:\n            n = self.lframes\n        assert self.window in ['rectangular',\n                               'bartlett', 'blackman', 'hamming', 'hanning']\n        if self.window == 'rectangular':\n            return np.ones(n)\n        elif self.window == 'bartlett':\n            return np.bartlett(n)\n        elif self.window == 'blackman':\n            return np.blackman(n)\n        elif self.window == 'hamming':\n            return np.hamming(n)\n        else:\n            return np.hanning(n)\n\n    def get_fft_freqs_only(self, x=None):\n\"\"\"Return FFT frequencies only\n\n        Args:\n            x (ndarray, optional): Complex valued data array. Defaults to None, in which \n            case object's own data_array is used.\n\n        Returns:\n            (ndarray): Frequency values\n        \"\"\"        \n        if x is None:\n            data = self.data_array\n        else:\n            data = x\n        n = data.size\n        ts = 1.0 / self.fs\n        f = np.fft.fftfreq(n, ts)\n        return np.fft.fftshift(f)\n\n    def get_fft(self, x=None, nframes=0, lframes=0):\n\"\"\"Calculate FFT. If nframes and lframes are provided then it\n        Reshapes the data to a 2D matrix, performs FFT in the horizontal\n        direction i.e. for each row, then averages in frequency domain in the\n        vertical direction, for every bin. The result is a flattened 1D\n        array that can be plotted using the frequencies.\n\n        Otherwise it is just the standard 1D FFT\n\n        Args:\n            x (ndarray, optional): Complex valued data array. Defaults to None.\n            nframes (int, optional): Number of frames. Defaults to 0.\n            lframes (int, optional): Length of frames. Defaults to 0.\n\n        Returns:\n            (tuple): Tuple of ndarrays, frequency, power and voltage\n        \"\"\"        \n\n        if nframes and lframes:\n            nf = nframes\n            lf = lframes\n        else:\n            nf = 1\n            lf = len(self.data_array)\n            # overwrite\n            if x is not None:\n                lf = len(x)\n\n        if x is None:\n            data = self.data_array\n        else:\n            data = x\n\n        termination = 50  # in Ohms for termination resistor\n        data = np.reshape(data, (nf, lf))\n        freqs = self.get_fft_freqs_only(data[0])\n        v_peak_iq = np.fft.fft(\n            data * self.get_window(lf), axis=1)\n        v_peak_iq = np.average(v_peak_iq, axis=0) / lf * nf\n        v_rms = abs(v_peak_iq) / np.sqrt(2)\n        p_avg = v_rms ** 2 / termination\n        # freqs is already fft shifted\n        return freqs, np.fft.fftshift(p_avg), np.fft.fftshift(v_peak_iq)\n\n    def get_pwelch(self, x=None):\n\"\"\" Create the power spectral density using Welch method\n\n        Args:\n            x (ndarray, optional): if available the data segment, otherwise the whole data will be taken. Defaults to None.\n\n        Returns:\n            (tuple): FFT and power in Watts\n        \"\"\"        \n        if x is None:\n            data = self.data_array\n        else:\n            data = x\n        n = data.size\n        f, p_avg = welch(data * self.get_window(n), self.fs,\n                         nperseg=data.size, return_onesided=False)\n        return np.fft.fftshift(f), np.fft.fftshift(p_avg)\n\n    def get_power_spectrogram(self, nframes, lframes):\n\"\"\"Get power spectrogram. Go through the data frame by frame and perform transformation. They can be plotted using pcolormesh\n        x, y and z are ndarrays and have the same shape. In order to access the contents use these kind of\n        indexing as below:\n\n        ```\n        #Slices parallel to frequency axis\n        nrows = np.shape(x)[0]\n        for i in range (nrows):\n            plt.plot(x[i,:], z[i,:])\n\n        #Slices parallel to time axis\n        ncols = np.shape(y)[1]\n        for i in range (ncols):\n            plt.plot(y[:,i], z[:, i])\n        ```\n\n        Args:\n            nframes (int): _description_\n            lframes (int): _description_\n\n        Returns:\n            (tuple): time, frequency and power as mesh grids\n        \"\"\"\n\n        assert self.method in ['fft', 'welch', 'mtm']\n\n        # define an empty np-array for appending\n        pout = np.zeros(nframes * lframes)\n\n        if self.method == 'fft':\n            sig = np.reshape(self.data_array, (nframes, lframes))\n            # fft must return power, so needs to be squared\n            zz = np.abs(np.fft.fftshift(np.fft.fft(sig, axis=1), axes=1)) ** 2\n\n        elif self.method == 'welch':\n            # go through the data array section wise and create a results array\n            for i in range(nframes):\n                f, p = self.get_pwelch(\n                    self.data_array[i * lframes:(i + 1) * lframes] * self.get_window(lframes))\n                pout[i * lframes:(i + 1) * lframes] = p\n            # fold the results array to the mesh grid\n            zz = np.reshape(pout, (nframes, lframes))\n\n        elif self.method == 'mtm':\n            mydpss = dpss(M=lframes, NW=4, Kmax=6)\n            #f = self.get_fft_freqs_only(x[0:lframes])\n            sig = np.reshape(self.data_array, (nframes, lframes))\n            zz = pmtm(sig, mydpss, axis=1)\n\n        # create a mesh grid from 0 to nframes -1 in Y direction\n        xx, yy = np.meshgrid(np.arange(lframes), np.arange(nframes))\n        yy = yy * lframes / self.fs\n        # center the frequencies around zero\n        xx = xx - xx[-1, -1] / 2\n        xx = xx * self.fs / lframes\n\n        return xx, yy, zz\n\n    def get_dp_p_vs_time(self, xx, yy, zz, eta):\n\"\"\"Returns two arrays for plotting dp_p vs time\n\n        Args:\n            xx (ndarray): Frequency meshgrid\n            yy (ndarray): Time meshgrid\n            zz (ndarray): Power meshgrid\n            eta (float): _description_\n\n        Returns:\n            (ndarray): Flattened array for 2D plot\n        \"\"\"        \n        # Slices parallel to frequency axis\n        n_time_frames = np.shape(xx)[0]\n        dp_p = np.zeros(n_time_frames)\n        for i in range(n_time_frames):\n            fwhm, f_peak, _, _ = IQBase.get_fwhm(xx[i, :], zz[i, :], skip=20)\n            dp_p[i] = fwhm / (f_peak + self.center) / eta\n\n        # Flatten array for 2D plot\n        return yy[:, 0], dp_p\n\n    def get_frame_power_vs_time(self, xx, yy, zz):\n\"\"\"Returns two arrays for plotting frame power vs time\n\n        Args:\n            xx (ndarray): Frequency meshgrid\n            yy (ndarray): Time meshgrid\n            zz (ndarray): Power meshgrid\n            eta (float): _description_\n\n        Returns:\n            (ndarray): Flattened array for 2D plot\n        \"\"\"        \n        # Slices parallel to frequency axis\n        n_time_frames = np.shape(xx)[0]\n        frame_power = np.zeros(n_time_frames)\n        for i in range(n_time_frames):\n            frame_power[i] = self.get_channel_power(xx[i, :], zz[i, :])\n\n        # Flatten array for 2D plot\n        return yy[:, 0], frame_power\n\n    @staticmethod\n    def get_frame_sum_vs_time(yy, zz):\n\"\"\"Return sum of the values in frame\n\n        Args:\n            yy (ndarray): Time meshgrid\n            zz (ndarray): Power meshgrid\n\n        Returns:\n            (float): Sum\n        \"\"\"        \n        summ = np.zeros(np.shape(zz)[0])\n        for i in range(len(summ)):\n            summ[i] = np.sum(zz[i, :])\n        return yy[:, 0], summ\n\n    @staticmethod\n    def get_fwhm(f, p, skip=None):\n\"\"\"Return the full width at half maximum.\n        f and p are arrays of points corresponding to the original data, whereas\n        the f_peak and p_peak are arrays of containing the coordinates of the peaks only\n\n        Args:\n            f (ndarray): _description_\n            p (ndarray): _description_\n            skip (int, optional): Sometimes peaks have a dip, skip this number of bins, use with care or visual inspection. Defaults to None.\n\n        Returns:\n            (float): Full width at half maximum\n        \"\"\"        \n        p_dbm = IQBase.get_dbm(p)\n        f_peak = p_dbm.max()\n        f_p3db = 0\n        f_m3db = 0\n        p_p3db = 0\n        p_m3db = 0\n        index_p3db = 0\n        index_m3db = 0\n        f_peak_index = p_dbm.argmax()\n        for i in range(f_peak_index, len(p_dbm)):\n            if skip is not None and i &lt; skip:\n                continue\n            if p_dbm[i] &lt;= (f_peak - 3):\n                p_p3db = p[i]\n                f_p3db = f[i]\n                index_p3db = i\n                break\n        for i in range(f_peak_index, -1, -1):\n            if skip is not None and f_peak_index - i &lt; skip:\n                continue\n            if p_dbm[i] &lt;= (f_peak - 3):\n                p_m3db = p[i]\n                f_m3db = f[i]\n                index_m3db = i\n                break\n        fwhm = f_p3db - f_m3db\n        # return watt values not dbm\n        return fwhm, f_peak, np.array([index_m3db, index_p3db]), np.array([f_m3db, f_p3db]), np.array([p_m3db, p_p3db])\n\n    @staticmethod\n    def get_sigma_estimate(f, p):\n\"\"\"Gets an estimate for sigma. Could be used for more precise fitting.\n\n        Args:\n            f (ndarray): ndarray of frequencies\n            p (ndarray): ndarray of powers\n\n        Returns:\n            (float): Estimage of sigma\n        \"\"\"        \n        p_peak = p.max()\n        f_peak_index = p.argmax()\n        f_peak = f[f_peak_index]\n        idx_phm = 0\n        idx_mhm = 0\n        rng_max = int(len(f) - len(f) / 4)\n        rng_min = int(len(f) - 3 * len(f) / 4)\n\n        for i in range(rng_max, rng_min, -1):\n            if p[i] &gt;= p_peak / 2:\n                idx_phm = i\n                break\n\n        for i in range(rng_min, rng_max):\n            if p[i] &gt;= p_peak / 2:\n                idx_mhm = i\n                break\n\n        return f_peak_index, idx_phm - idx_mhm, idx_mhm, idx_phm\n\n    @staticmethod\n    def get_narrow_peaks_dbm(f, p, accuracy=50):\n\"\"\"Find narrow peaks and return them\n\n        Args:\n            f (ndarray): ndarray of frequencies\n            p (ndarray): ndarray of powers\n            accuracy (int, optional): A number to adjust sensitivity of the peak finder. Defaults to 50.\n\n        Returns:\n            (ndarray): ndarray of peaks and their indexes\n        \"\"\"        \n        # convert to dbm for convenience\n        p_dbm = IQBase.get_dbm(p)\n        peak_ind = find_peaks_cwt(p_dbm, np.arange(1, accuracy))\n        # return the watt value, not dbm\n        return np.array(f[peak_ind]), np.array(p[peak_ind])\n\n    @staticmethod\n    def get_broad_peak_dbm(f, p):\n\"\"\"Returns the maximum usually useful for a broad peak\n\n        Args:\n            f (ndarray): ndarray of frequencies\n            p (ndarray): ndarray of powers\n\n        Returns:\n            (ndarray): Coordinates of the peak\n        \"\"\"        \n        # return as an array for compatibility\n        return np.array([f[p.argmax()]]), np.array([p.max()])\n\n    @staticmethod\n    def get_dbm(watt):\n\"\"\"Convert Watt to dBm\n\n        Args:\n            watt (float): Value in Watts\n\n        Returns:\n            (float): Value in dBm\n        \"\"\"        \n        if isinstance(watt, np.ndarray):\n            watt[watt &lt;= 0] = 10 ** -30\n        return 10 * np.log10(np.array(watt) * 1000)\n\n    @staticmethod\n    def get_watt(dbm):\n\"\"\"Convert dBm to Watts\n\n        Args:\n            dbm (float): Value in dBm\n\n        Returns:\n            (float): Value in Watts\n        \"\"\"        \n        return 10 ** (np.array(dbm) / 10) / 1000\n\n    def get_channel_power(self, f, p, span=None):\n\"\"\"Return total power in band in Watts, considering noise bandwidth\n\n        Args:\n            f (ndarray): ndarray of frequencies\n            p (ndarray): ndarray of powers\n            span (float, optional): Frequency window. Defaults to None.\n\n        Returns:\n            (float): Channel power\n        \"\"\"        \n        if not span:\n            mask = (f != 0) | (f == 0)\n        else:\n            mask = (f &lt;= span / 2) &amp; (f &gt;= -span / 2)\n\n        # based on agilent application note on RBW and ENBW\n        # for typical FFT based analysers\n        #nbw = self.rbw * 5\n        nbw = self.rbw * 1.056\n        summ = np.sum(p[mask])\n        # ACQ bandwidth here is a better measure.\n        # correct formula uses NBW\n        # final = summ / np.size(p) * self.acq_bw / nbw\n        final = summ / nbw\n        return final\n\n    @staticmethod\n    def zoom_in_freq(f, p, center=0, span=1000):\n\"\"\"Cut the frequency domain data\n\n        Args:\n            f (ndarray): ndarray of frequencies\n            p (ndarray): ndarray of powers\n            center (float, optional): Center index. Defaults to 0.\n            span (float, optional): Frequency window. Defaults to 1000.\n\n        Returns:\n            (tuple): Frequency and power\n        \"\"\"        \n        low = center - span / 2\n        high = center + span / 2\n        mask = (f &gt; low) &amp; (f &lt; high)\n        return f[mask], p[mask]\n\n    @staticmethod\n    def shift_cut_data_time(x, val):\n\"\"\"Handy tool to shift and cut data in time domain\n\n        Args:\n            x (ndarray): Data array\n            val (int): Shift index\n\n        Returns:\n            (tuple): Shift and cut version\n        \"\"\"        \n        return x[:-val], x[val:]\n\n    @staticmethod\n    def shift_to_center_frequency(f, center):\n\"\"\"Just return the shifted frequency to center\n\n        Args:\n            f (ndarray): Array of frequencies\n            center (float): Center frequency\n\n        Returns:\n            (ndarray): Shifted array of frequencies\n        \"\"\"        \n        return center + f\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.dic2htmlstring","title":"<code>dic2htmlstring(dic)</code>","text":"<p>Converts a dictionary to an HTML string</p> <p>Parameters:</p> Name Type Description Default <code>dic</code> <code>dictionary</code> <p>Dictionary of values</p> required <p>Returns:</p> Type Description <code>string</code> <p>HTML String</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>def dic2htmlstring(self, dic):\n\"\"\"Converts a dictionary to an HTML string\n\n    Args:\n        dic (dictionary): Dictionary of values\n\n    Returns:\n        (string): HTML String\n    \"\"\"        \n    outstr = ''\n    if 'filename' in dic:\n        outstr += '&lt;font size=\"4\" color=\"green\"&gt;File name:&lt;/font&gt; {} &lt;font size=\"4\" color=\"green\"&gt;&lt;/font&gt;&lt;br&gt;\\n'.format(\n            self.filename)\n    if 'nsamples_total' in dic:\n        outstr += '&lt;font size=\"4\" color=\"green\"&gt;Record length:&lt;/font&gt; {:.2e} &lt;font size=\"4\" color=\"green\"&gt;[s]&lt;/font&gt;&lt;br&gt;\\n'.format(\n            self.get_record_length())\n    if 'nsamples_total' in dic:\n        outstr += '&lt;font size=\"4\" color=\"green\"&gt;No. Samples:&lt;/font&gt; {} &lt;br&gt;\\n'.format(\n            self.nsamples_total)\n    if 'fs' in dic:\n        outstr += '&lt;font size=\"4\" color=\"green\"&gt;Sampling rate:&lt;/font&gt; {} &lt;font size=\"4\" color=\"green\"&gt;[sps]&lt;/font&gt;&lt;br&gt;\\n'.format(\n            self.fs)\n    if 'center' in dic:\n        outstr += '&lt;font size=\"4\" color=\"green\"&gt;Center freq.:&lt;/font&gt; {} &lt;font size=\"4\" color=\"green\"&gt;[Hz]&lt;/font&gt;&lt;br&gt;\\n'.format(\n            self.center)\n    if 'span' in dic:\n        outstr += '&lt;font size=\"4\" color=\"green\"&gt;Span:&lt;/font&gt; {} &lt;font size=\"4\" color=\"green\"&gt;[Hz]&lt;/font&gt;&lt;br&gt;\\n'.format(\n            self.span)\n    if 'acq_bw' in dic:\n        outstr += '&lt;font size=\"4\" color=\"green\"&gt;Acq. BW.:&lt;/font&gt; {} &lt;br&gt;\\n'.format(\n            self.acq_bw)\n    if 'rbw' in dic:\n        outstr += '&lt;font size=\"4\" color=\"green\"&gt;RBW:&lt;/font&gt; {} &lt;br&gt;\\n'.format(\n            self.rbw)\n    if 'rf_att' in dic:\n        outstr += '&lt;font size=\"4\" color=\"green\"&gt;RF Att.:&lt;/font&gt; {} &lt;br&gt;\\n'.format(\n            self.rf_att)\n    if 'date_time' in dic:\n        outstr += '&lt;font size=\"4\" color=\"green\"&gt;Date and Time:&lt;/font&gt; {} &lt;br&gt;\\n'.format(\n            self.date_time)\n        return outstr\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.get_broad_peak_dbm","title":"<code>get_broad_peak_dbm(f, p)</code>  <code>staticmethod</code>","text":"<p>Returns the maximum usually useful for a broad peak</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>ndarray</code> <p>ndarray of frequencies</p> required <code>p</code> <code>ndarray</code> <p>ndarray of powers</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Coordinates of the peak</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>@staticmethod\ndef get_broad_peak_dbm(f, p):\n\"\"\"Returns the maximum usually useful for a broad peak\n\n    Args:\n        f (ndarray): ndarray of frequencies\n        p (ndarray): ndarray of powers\n\n    Returns:\n        (ndarray): Coordinates of the peak\n    \"\"\"        \n    # return as an array for compatibility\n    return np.array([f[p.argmax()]]), np.array([p.max()])\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.get_channel_power","title":"<code>get_channel_power(f, p, span=None)</code>","text":"<p>Return total power in band in Watts, considering noise bandwidth</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>ndarray</code> <p>ndarray of frequencies</p> required <code>p</code> <code>ndarray</code> <p>ndarray of powers</p> required <code>span</code> <code>float</code> <p>Frequency window. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Channel power</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>def get_channel_power(self, f, p, span=None):\n\"\"\"Return total power in band in Watts, considering noise bandwidth\n\n    Args:\n        f (ndarray): ndarray of frequencies\n        p (ndarray): ndarray of powers\n        span (float, optional): Frequency window. Defaults to None.\n\n    Returns:\n        (float): Channel power\n    \"\"\"        \n    if not span:\n        mask = (f != 0) | (f == 0)\n    else:\n        mask = (f &lt;= span / 2) &amp; (f &gt;= -span / 2)\n\n    # based on agilent application note on RBW and ENBW\n    # for typical FFT based analysers\n    #nbw = self.rbw * 5\n    nbw = self.rbw * 1.056\n    summ = np.sum(p[mask])\n    # ACQ bandwidth here is a better measure.\n    # correct formula uses NBW\n    # final = summ / np.size(p) * self.acq_bw / nbw\n    final = summ / nbw\n    return final\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.get_dbm","title":"<code>get_dbm(watt)</code>  <code>staticmethod</code>","text":"<p>Convert Watt to dBm</p> <p>Parameters:</p> Name Type Description Default <code>watt</code> <code>float</code> <p>Value in Watts</p> required <p>Returns:</p> Type Description <code>float</code> <p>Value in dBm</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>@staticmethod\ndef get_dbm(watt):\n\"\"\"Convert Watt to dBm\n\n    Args:\n        watt (float): Value in Watts\n\n    Returns:\n        (float): Value in dBm\n    \"\"\"        \n    if isinstance(watt, np.ndarray):\n        watt[watt &lt;= 0] = 10 ** -30\n    return 10 * np.log10(np.array(watt) * 1000)\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.get_dp_p_vs_time","title":"<code>get_dp_p_vs_time(xx, yy, zz, eta)</code>","text":"<p>Returns two arrays for plotting dp_p vs time</p> <p>Parameters:</p> Name Type Description Default <code>xx</code> <code>ndarray</code> <p>Frequency meshgrid</p> required <code>yy</code> <code>ndarray</code> <p>Time meshgrid</p> required <code>zz</code> <code>ndarray</code> <p>Power meshgrid</p> required <code>eta</code> <code>float</code> <p>description</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Flattened array for 2D plot</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>def get_dp_p_vs_time(self, xx, yy, zz, eta):\n\"\"\"Returns two arrays for plotting dp_p vs time\n\n    Args:\n        xx (ndarray): Frequency meshgrid\n        yy (ndarray): Time meshgrid\n        zz (ndarray): Power meshgrid\n        eta (float): _description_\n\n    Returns:\n        (ndarray): Flattened array for 2D plot\n    \"\"\"        \n    # Slices parallel to frequency axis\n    n_time_frames = np.shape(xx)[0]\n    dp_p = np.zeros(n_time_frames)\n    for i in range(n_time_frames):\n        fwhm, f_peak, _, _ = IQBase.get_fwhm(xx[i, :], zz[i, :], skip=20)\n        dp_p[i] = fwhm / (f_peak + self.center) / eta\n\n    # Flatten array for 2D plot\n    return yy[:, 0], dp_p\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.get_fft","title":"<code>get_fft(x=None, nframes=0, lframes=0)</code>","text":"<p>Calculate FFT. If nframes and lframes are provided then it Reshapes the data to a 2D matrix, performs FFT in the horizontal direction i.e. for each row, then averages in frequency domain in the vertical direction, for every bin. The result is a flattened 1D array that can be plotted using the frequencies.</p> <p>Otherwise it is just the standard 1D FFT</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Complex valued data array. Defaults to None.</p> <code>None</code> <code>nframes</code> <code>int</code> <p>Number of frames. Defaults to 0.</p> <code>0</code> <code>lframes</code> <code>int</code> <p>Length of frames. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of ndarrays, frequency, power and voltage</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>def get_fft(self, x=None, nframes=0, lframes=0):\n\"\"\"Calculate FFT. If nframes and lframes are provided then it\n    Reshapes the data to a 2D matrix, performs FFT in the horizontal\n    direction i.e. for each row, then averages in frequency domain in the\n    vertical direction, for every bin. The result is a flattened 1D\n    array that can be plotted using the frequencies.\n\n    Otherwise it is just the standard 1D FFT\n\n    Args:\n        x (ndarray, optional): Complex valued data array. Defaults to None.\n        nframes (int, optional): Number of frames. Defaults to 0.\n        lframes (int, optional): Length of frames. Defaults to 0.\n\n    Returns:\n        (tuple): Tuple of ndarrays, frequency, power and voltage\n    \"\"\"        \n\n    if nframes and lframes:\n        nf = nframes\n        lf = lframes\n    else:\n        nf = 1\n        lf = len(self.data_array)\n        # overwrite\n        if x is not None:\n            lf = len(x)\n\n    if x is None:\n        data = self.data_array\n    else:\n        data = x\n\n    termination = 50  # in Ohms for termination resistor\n    data = np.reshape(data, (nf, lf))\n    freqs = self.get_fft_freqs_only(data[0])\n    v_peak_iq = np.fft.fft(\n        data * self.get_window(lf), axis=1)\n    v_peak_iq = np.average(v_peak_iq, axis=0) / lf * nf\n    v_rms = abs(v_peak_iq) / np.sqrt(2)\n    p_avg = v_rms ** 2 / termination\n    # freqs is already fft shifted\n    return freqs, np.fft.fftshift(p_avg), np.fft.fftshift(v_peak_iq)\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.get_fft_freqs_only","title":"<code>get_fft_freqs_only(x=None)</code>","text":"<p>Return FFT frequencies only</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Complex valued data array. Defaults to None, in which </p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Frequency values</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>def get_fft_freqs_only(self, x=None):\n\"\"\"Return FFT frequencies only\n\n    Args:\n        x (ndarray, optional): Complex valued data array. Defaults to None, in which \n        case object's own data_array is used.\n\n    Returns:\n        (ndarray): Frequency values\n    \"\"\"        \n    if x is None:\n        data = self.data_array\n    else:\n        data = x\n    n = data.size\n    ts = 1.0 / self.fs\n    f = np.fft.fftfreq(n, ts)\n    return np.fft.fftshift(f)\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.get_frame_power_vs_time","title":"<code>get_frame_power_vs_time(xx, yy, zz)</code>","text":"<p>Returns two arrays for plotting frame power vs time</p> <p>Parameters:</p> Name Type Description Default <code>xx</code> <code>ndarray</code> <p>Frequency meshgrid</p> required <code>yy</code> <code>ndarray</code> <p>Time meshgrid</p> required <code>zz</code> <code>ndarray</code> <p>Power meshgrid</p> required <code>eta</code> <code>float</code> <p>description</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Flattened array for 2D plot</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>def get_frame_power_vs_time(self, xx, yy, zz):\n\"\"\"Returns two arrays for plotting frame power vs time\n\n    Args:\n        xx (ndarray): Frequency meshgrid\n        yy (ndarray): Time meshgrid\n        zz (ndarray): Power meshgrid\n        eta (float): _description_\n\n    Returns:\n        (ndarray): Flattened array for 2D plot\n    \"\"\"        \n    # Slices parallel to frequency axis\n    n_time_frames = np.shape(xx)[0]\n    frame_power = np.zeros(n_time_frames)\n    for i in range(n_time_frames):\n        frame_power[i] = self.get_channel_power(xx[i, :], zz[i, :])\n\n    # Flatten array for 2D plot\n    return yy[:, 0], frame_power\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.get_frame_sum_vs_time","title":"<code>get_frame_sum_vs_time(yy, zz)</code>  <code>staticmethod</code>","text":"<p>Return sum of the values in frame</p> <p>Parameters:</p> Name Type Description Default <code>yy</code> <code>ndarray</code> <p>Time meshgrid</p> required <code>zz</code> <code>ndarray</code> <p>Power meshgrid</p> required <p>Returns:</p> Type Description <code>float</code> <p>Sum</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>@staticmethod\ndef get_frame_sum_vs_time(yy, zz):\n\"\"\"Return sum of the values in frame\n\n    Args:\n        yy (ndarray): Time meshgrid\n        zz (ndarray): Power meshgrid\n\n    Returns:\n        (float): Sum\n    \"\"\"        \n    summ = np.zeros(np.shape(zz)[0])\n    for i in range(len(summ)):\n        summ[i] = np.sum(zz[i, :])\n    return yy[:, 0], summ\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.get_fwhm","title":"<code>get_fwhm(f, p, skip=None)</code>  <code>staticmethod</code>","text":"<p>Return the full width at half maximum. f and p are arrays of points corresponding to the original data, whereas the f_peak and p_peak are arrays of containing the coordinates of the peaks only</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>ndarray</code> <p>description</p> required <code>p</code> <code>ndarray</code> <p>description</p> required <code>skip</code> <code>int</code> <p>Sometimes peaks have a dip, skip this number of bins, use with care or visual inspection. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Full width at half maximum</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>@staticmethod\ndef get_fwhm(f, p, skip=None):\n\"\"\"Return the full width at half maximum.\n    f and p are arrays of points corresponding to the original data, whereas\n    the f_peak and p_peak are arrays of containing the coordinates of the peaks only\n\n    Args:\n        f (ndarray): _description_\n        p (ndarray): _description_\n        skip (int, optional): Sometimes peaks have a dip, skip this number of bins, use with care or visual inspection. Defaults to None.\n\n    Returns:\n        (float): Full width at half maximum\n    \"\"\"        \n    p_dbm = IQBase.get_dbm(p)\n    f_peak = p_dbm.max()\n    f_p3db = 0\n    f_m3db = 0\n    p_p3db = 0\n    p_m3db = 0\n    index_p3db = 0\n    index_m3db = 0\n    f_peak_index = p_dbm.argmax()\n    for i in range(f_peak_index, len(p_dbm)):\n        if skip is not None and i &lt; skip:\n            continue\n        if p_dbm[i] &lt;= (f_peak - 3):\n            p_p3db = p[i]\n            f_p3db = f[i]\n            index_p3db = i\n            break\n    for i in range(f_peak_index, -1, -1):\n        if skip is not None and f_peak_index - i &lt; skip:\n            continue\n        if p_dbm[i] &lt;= (f_peak - 3):\n            p_m3db = p[i]\n            f_m3db = f[i]\n            index_m3db = i\n            break\n    fwhm = f_p3db - f_m3db\n    # return watt values not dbm\n    return fwhm, f_peak, np.array([index_m3db, index_p3db]), np.array([f_m3db, f_p3db]), np.array([p_m3db, p_p3db])\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.get_narrow_peaks_dbm","title":"<code>get_narrow_peaks_dbm(f, p, accuracy=50)</code>  <code>staticmethod</code>","text":"<p>Find narrow peaks and return them</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>ndarray</code> <p>ndarray of frequencies</p> required <code>p</code> <code>ndarray</code> <p>ndarray of powers</p> required <code>accuracy</code> <code>int</code> <p>A number to adjust sensitivity of the peak finder. Defaults to 50.</p> <code>50</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>ndarray of peaks and their indexes</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>@staticmethod\ndef get_narrow_peaks_dbm(f, p, accuracy=50):\n\"\"\"Find narrow peaks and return them\n\n    Args:\n        f (ndarray): ndarray of frequencies\n        p (ndarray): ndarray of powers\n        accuracy (int, optional): A number to adjust sensitivity of the peak finder. Defaults to 50.\n\n    Returns:\n        (ndarray): ndarray of peaks and their indexes\n    \"\"\"        \n    # convert to dbm for convenience\n    p_dbm = IQBase.get_dbm(p)\n    peak_ind = find_peaks_cwt(p_dbm, np.arange(1, accuracy))\n    # return the watt value, not dbm\n    return np.array(f[peak_ind]), np.array(p[peak_ind])\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.get_power_spectrogram","title":"<code>get_power_spectrogram(nframes, lframes)</code>","text":"<p>Get power spectrogram. Go through the data frame by frame and perform transformation. They can be plotted using pcolormesh x, y and z are ndarrays and have the same shape. In order to access the contents use these kind of indexing as below:</p> <pre><code>#Slices parallel to frequency axis\nnrows = np.shape(x)[0]\nfor i in range (nrows):\n    plt.plot(x[i,:], z[i,:])\n\n#Slices parallel to time axis\nncols = np.shape(y)[1]\nfor i in range (ncols):\n    plt.plot(y[:,i], z[:, i])\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>nframes</code> <code>int</code> <p>description</p> required <code>lframes</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>time, frequency and power as mesh grids</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>def get_power_spectrogram(self, nframes, lframes):\n\"\"\"Get power spectrogram. Go through the data frame by frame and perform transformation. They can be plotted using pcolormesh\n    x, y and z are ndarrays and have the same shape. In order to access the contents use these kind of\n    indexing as below:\n\n    ```\n    #Slices parallel to frequency axis\n    nrows = np.shape(x)[0]\n    for i in range (nrows):\n        plt.plot(x[i,:], z[i,:])\n\n    #Slices parallel to time axis\n    ncols = np.shape(y)[1]\n    for i in range (ncols):\n        plt.plot(y[:,i], z[:, i])\n    ```\n\n    Args:\n        nframes (int): _description_\n        lframes (int): _description_\n\n    Returns:\n        (tuple): time, frequency and power as mesh grids\n    \"\"\"\n\n    assert self.method in ['fft', 'welch', 'mtm']\n\n    # define an empty np-array for appending\n    pout = np.zeros(nframes * lframes)\n\n    if self.method == 'fft':\n        sig = np.reshape(self.data_array, (nframes, lframes))\n        # fft must return power, so needs to be squared\n        zz = np.abs(np.fft.fftshift(np.fft.fft(sig, axis=1), axes=1)) ** 2\n\n    elif self.method == 'welch':\n        # go through the data array section wise and create a results array\n        for i in range(nframes):\n            f, p = self.get_pwelch(\n                self.data_array[i * lframes:(i + 1) * lframes] * self.get_window(lframes))\n            pout[i * lframes:(i + 1) * lframes] = p\n        # fold the results array to the mesh grid\n        zz = np.reshape(pout, (nframes, lframes))\n\n    elif self.method == 'mtm':\n        mydpss = dpss(M=lframes, NW=4, Kmax=6)\n        #f = self.get_fft_freqs_only(x[0:lframes])\n        sig = np.reshape(self.data_array, (nframes, lframes))\n        zz = pmtm(sig, mydpss, axis=1)\n\n    # create a mesh grid from 0 to nframes -1 in Y direction\n    xx, yy = np.meshgrid(np.arange(lframes), np.arange(nframes))\n    yy = yy * lframes / self.fs\n    # center the frequencies around zero\n    xx = xx - xx[-1, -1] / 2\n    xx = xx * self.fs / lframes\n\n    return xx, yy, zz\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.get_pwelch","title":"<code>get_pwelch(x=None)</code>","text":"<p>Create the power spectral density using Welch method</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>if available the data segment, otherwise the whole data will be taken. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>FFT and power in Watts</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>def get_pwelch(self, x=None):\n\"\"\" Create the power spectral density using Welch method\n\n    Args:\n        x (ndarray, optional): if available the data segment, otherwise the whole data will be taken. Defaults to None.\n\n    Returns:\n        (tuple): FFT and power in Watts\n    \"\"\"        \n    if x is None:\n        data = self.data_array\n    else:\n        data = x\n    n = data.size\n    f, p_avg = welch(data * self.get_window(n), self.fs,\n                     nperseg=data.size, return_onesided=False)\n    return np.fft.fftshift(f), np.fft.fftshift(p_avg)\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.get_record_length","title":"<code>get_record_length()</code>","text":"<p>Returns the record length</p> <p>Returns:</p> Type Description <code>float</code> <p>record length</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>def get_record_length(self):\n\"\"\"Returns the record length\n\n    Returns:\n        (float): record length\n    \"\"\"        \n    return self.nsamples_total / self.fs\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.get_sigma_estimate","title":"<code>get_sigma_estimate(f, p)</code>  <code>staticmethod</code>","text":"<p>Gets an estimate for sigma. Could be used for more precise fitting.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>ndarray</code> <p>ndarray of frequencies</p> required <code>p</code> <code>ndarray</code> <p>ndarray of powers</p> required <p>Returns:</p> Type Description <code>float</code> <p>Estimage of sigma</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>@staticmethod\ndef get_sigma_estimate(f, p):\n\"\"\"Gets an estimate for sigma. Could be used for more precise fitting.\n\n    Args:\n        f (ndarray): ndarray of frequencies\n        p (ndarray): ndarray of powers\n\n    Returns:\n        (float): Estimage of sigma\n    \"\"\"        \n    p_peak = p.max()\n    f_peak_index = p.argmax()\n    f_peak = f[f_peak_index]\n    idx_phm = 0\n    idx_mhm = 0\n    rng_max = int(len(f) - len(f) / 4)\n    rng_min = int(len(f) - 3 * len(f) / 4)\n\n    for i in range(rng_max, rng_min, -1):\n        if p[i] &gt;= p_peak / 2:\n            idx_phm = i\n            break\n\n    for i in range(rng_min, rng_max):\n        if p[i] &gt;= p_peak / 2:\n            idx_mhm = i\n            break\n\n    return f_peak_index, idx_phm - idx_mhm, idx_mhm, idx_phm\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.get_watt","title":"<code>get_watt(dbm)</code>  <code>staticmethod</code>","text":"<p>Convert dBm to Watts</p> <p>Parameters:</p> Name Type Description Default <code>dbm</code> <code>float</code> <p>Value in dBm</p> required <p>Returns:</p> Type Description <code>float</code> <p>Value in Watts</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>@staticmethod\ndef get_watt(dbm):\n\"\"\"Convert dBm to Watts\n\n    Args:\n        dbm (float): Value in dBm\n\n    Returns:\n        (float): Value in Watts\n    \"\"\"        \n    return 10 ** (np.array(dbm) / 10) / 1000\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.get_window","title":"<code>get_window(n=None)</code>","text":"<p>Return a suitable windowing function for FFT</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Window length. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>FFT Window</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>def get_window(self, n=None):\n\"\"\"Return a suitable windowing function for FFT\n\n    Args:\n        n (int, optional): Window length. Defaults to None.\n\n    Returns:\n        (ndarray): FFT Window\n    \"\"\"        \n    if not n:\n        n = self.lframes\n    assert self.window in ['rectangular',\n                           'bartlett', 'blackman', 'hamming', 'hanning']\n    if self.window == 'rectangular':\n        return np.ones(n)\n    elif self.window == 'bartlett':\n        return np.bartlett(n)\n    elif self.window == 'blackman':\n        return np.blackman(n)\n    elif self.window == 'hamming':\n        return np.hamming(n)\n    else:\n        return np.hanning(n)\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.read","title":"<code>read(nframes, lframes, sframes)</code>  <code>abstractmethod</code>","text":"<p>Abstract method</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>@abstractmethod\ndef read(self, nframes, lframes, sframes):\n\"\"\"Abstract method\n    \"\"\"        \n    pass\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.read_samples","title":"<code>read_samples(nsamples, offset)</code>  <code>abstractmethod</code>","text":"<p>Abstract method</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>@abstractmethod\ndef read_samples(self, nsamples, offset):\n\"\"\"Abstract method\n    \"\"\"        \n    pass\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.shift_cut_data_time","title":"<code>shift_cut_data_time(x, val)</code>  <code>staticmethod</code>","text":"<p>Handy tool to shift and cut data in time domain</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Data array</p> required <code>val</code> <code>int</code> <p>Shift index</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Shift and cut version</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>@staticmethod\ndef shift_cut_data_time(x, val):\n\"\"\"Handy tool to shift and cut data in time domain\n\n    Args:\n        x (ndarray): Data array\n        val (int): Shift index\n\n    Returns:\n        (tuple): Shift and cut version\n    \"\"\"        \n    return x[:-val], x[val:]\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.shift_to_center_frequency","title":"<code>shift_to_center_frequency(f, center)</code>  <code>staticmethod</code>","text":"<p>Just return the shifted frequency to center</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>ndarray</code> <p>Array of frequencies</p> required <code>center</code> <code>float</code> <p>Center frequency</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Shifted array of frequencies</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>@staticmethod\ndef shift_to_center_frequency(f, center):\n\"\"\"Just return the shifted frequency to center\n\n    Args:\n        f (ndarray): Array of frequencies\n        center (float): Center frequency\n\n    Returns:\n        (ndarray): Shifted array of frequencies\n    \"\"\"        \n    return center + f\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.IQBase.zoom_in_freq","title":"<code>zoom_in_freq(f, p, center=0, span=1000)</code>  <code>staticmethod</code>","text":"<p>Cut the frequency domain data</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>ndarray</code> <p>ndarray of frequencies</p> required <code>p</code> <code>ndarray</code> <p>ndarray of powers</p> required <code>center</code> <code>float</code> <p>Center index. Defaults to 0.</p> <code>0</code> <code>span</code> <code>float</code> <p>Frequency window. Defaults to 1000.</p> <code>1000</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Frequency and power</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>@staticmethod\ndef zoom_in_freq(f, p, center=0, span=1000):\n\"\"\"Cut the frequency domain data\n\n    Args:\n        f (ndarray): ndarray of frequencies\n        p (ndarray): ndarray of powers\n        center (float, optional): Center index. Defaults to 0.\n        span (float, optional): Frequency window. Defaults to 1000.\n\n    Returns:\n        (tuple): Frequency and power\n    \"\"\"        \n    low = center - span / 2\n    high = center + span / 2\n    mask = (f &gt; low) &amp; (f &lt; high)\n    return f[mask], p[mask]\n</code></pre>"},{"location":"references/iqbase/#iqtools.iqbase.pmtm","title":"<code>pmtm(signal, dpss, axis=-1)</code>","text":"<p>Estimate the power spectral density of the input signal. This function is adopted from this project which was in turn a fork of this project.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>ndarray</code> <p>n-dimensional array of real or complex values</p> required <code>dpss</code> <code>ndarray</code> <p>The Slepian matrix</p> required <code>axis</code> <code>int</code> <p>Axis along which to apply the Slepian windows. Default is the last one. Defaults to -1.</p> <code>-1</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>The multitaper frame, shifted in the correct order</p> Source code in <code>iqtools/iqbase.py</code> <pre><code>def pmtm(signal, dpss, axis=-1):\n\"\"\"Estimate the power spectral density of the input signal. This function is adopted from [this project](https://github.com/xaratustrah/multitaper) which was in turn a fork of [this project](https://github.com/nerdull/multitaper).\n\n    Args:\n        signal (ndarray): n-dimensional array of real or complex values\n        dpss (ndarray): The Slepian matrix\n        axis (int, optional): Axis along which to apply the Slepian windows. Default is the last one. Defaults to -1.\n\n    Returns:\n        (ndarray): The multitaper frame, shifted in the correct order\n    \"\"\"    \n    # conversion to positive-only index\n    axis_p = (axis + signal.ndim) % signal.ndim\n    sig_exp_shape = list(signal.shape[:axis]) + [1] + list(signal.shape[axis:])\n    tap_exp_shape = [1] * axis_p + \\\n        list(dpss.shape) + [1] * (signal.ndim - 1 - axis_p)\n    signal_tapered = signal.reshape(\n        sig_exp_shape) * dpss.reshape(tap_exp_shape)\n    return np.fft.fftshift(np.mean(np.absolute(np.fft.fft(signal_tapered, axis=axis_p + 1))**2, axis=axis_p), axes=axis_p)\n</code></pre>"},{"location":"references/iqtdata/","title":"IQTData","text":"<p>Class for IQ Data IQT format</p> <p>xaratustrah@github Aug-2015</p>"},{"location":"references/iqtdata/#iqtools.iqtdata.IQTData","title":"<code>IQTData</code>","text":"<p>         Bases: <code>IQBase</code></p> Source code in <code>iqtools/iqtdata.py</code> <pre><code>class IQTData(IQBase):\n    def __init__(self, filename):\n        super().__init__(filename)\n\n        # Additional fields in this subclass\n        self.header = ''\n        self.span = 0\n        self.fft_points = 0\n        self.level_offset = 0\n        self.frame_length = 0\n        self.gain_offset = 0\n        self.max_input_level = 0\n        self.scale = 0\n\n    def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n        Args:\n            nframes (int, optional): Number of frames to be read. Defaults to 10.\n            lframes (int, optional): Length of each frame. Defaults to 1024.\n            sframes (int, optional): Starting frame. Defaults to 0.\n        \"\"\"        \n        # in iqt files, lframes is always fixed 1024 at the time of reading the file.\n        # At the usage time, the lframe can be changed from time data\n\n        data_offset = 0\n        with open(self.filename, 'rb') as f:\n            ba = f.read(1)\n            data_offset += 1\n            header_size_size = int(ba.decode('utf8'))\n            ba = f.read(header_size_size)\n            data_offset += header_size_size\n            header_size = int(ba.decode('utf8'))\n            ba = f.read(header_size)\n            data_offset += header_size\n\n        self.header = ba.decode('utf8').split('\\n')\n        header_dic = self.read_header(self.header)\n\n        self.fft_points = int(header_dic['FFTPoints'])\n        self.max_input_level = float(header_dic['MaxInputLevel'])\n        self.level_offset = float(header_dic['LevelOffset'])\n        self.frame_length = float(header_dic['FrameLength'])\n        self.gain_offset = float(header_dic['GainOffset'])\n        self.center = float(header_dic['CenterFrequency'])\n        self.span = float(header_dic['Span'])\n        self.nframes_tot = int(header_dic['ValidFrames'])\n        self.date_time = header_dic['DateTime']\n\n        self.nsamples_total = self.nframes_tot * self.fft_points\n        self.fs = self.fft_points / self.frame_length\n\n        self.scale = np.sqrt(np.power(\n            10, (self.gain_offset + self.max_input_level + self.level_offset) / 10) / 20 * 2)\n\n        log.info(\"Proceeding to read binary section, 32bit (4 byte) little endian.\")\n\n        frame_header_type = np.dtype(\n            {'names': ['reserved1', 'validA', 'validP', 'validI', 'validQ', 'bins', 'reserved2', 'triggered',\n                       'overLoad', 'lastFrame', 'ticks'],\n             'formats': [np.int16, np.int16, np.int16, np.int16, np.int16, np.int16, np.int16,\n                         np.int16, np.int16, np.int16, np.int32]})\n\n        # 2 byte integer for Q, 2 byte integer for I\n        frame_data_type = np.dtype((np.int16, 2 * lframes))\n        frame_type = np.dtype({'names': ['header', 'data'],\n                               'formats': [(frame_header_type, 1), (frame_data_type, 1)]})\n\n        total_n_bytes = nframes * frame_type.itemsize\n        start_n_bytes = sframes * frame_type.itemsize\n\n        # prepare an empty array with enough room\n        self.data_array = np.zeros(lframes * nframes, np.complex64)\n\n        # Read n frames at once\n        try:\n            with open(self.filename, 'rb') as f:\n                f.seek(data_offset + start_n_bytes)\n                ba = f.read(total_n_bytes)\n        except:\n            log.error('File seems to end here!')\n            return\n\n        # print(len(ba))\n        frame_array = np.fromstring(ba, dtype=frame_type)\n\n        for i in range(frame_array.size):\n            temp_array = np.zeros(2 * lframes, np.int16)\n            temp_array[::2], temp_array[1::2] = frame_array[i]['data'][1::2], frame_array[i]['data'][::2]\n            temp_array = temp_array.astype(np.float32)\n            temp_array = temp_array.view(np.complex64)\n            self.data_array[i * lframes:(i + 1) * lframes] = temp_array\n        # and finally scale the data\n        self.data_array = self.data_array * self.scale\n        # todo: correction data block\n\n    # def read_iq(self, nframes=10, lframes=1024, sframes=1):\n    #     \"\"\"\n    #     Read Sony/Tektronix IQ Files\n    #     :param nframes:\n    #     :param lframes:\n    #     :param sframes:\n    #     :return:\n    #     \"\"\"\n    #     # in iqt files, lframes is always fixed 1024 at the time of reading the file.\n    #     # At the usage time, the lframe can be changed from time data\n    #\n    #     self.lframes = lframes\n    #     self.nframes = nframes\n    #\n    #     data_offset = 0\n    #     with open(self.filename, 'rb') as f:\n    #         ba = f.read(1)\n    #         data_offset += 1\n    #         header_size_size = int(ba.decode('utf8'))\n    #         ba = f.read(header_size_size)\n    #         data_offset += header_size_size\n    #         header_size = int(ba.decode('utf8'))\n    #         ba = f.read(header_size)\n    #         data_offset += header_size\n    #\n    #     self.header = ba.decode('utf8').split('\\n')\n    #     header_dic = self.read_header(self.header)\n    #\n    #     fft_points = int(header_dic['FFTPoints'])\n    #     max_input_level = float(header_dic['MaxInputLevel'])\n    #     level_offset = float(header_dic['LevelOffset'])\n    #     frame_length = float(header_dic['FrameLength'])\n    #     gain_offset = float(header_dic['GainOffset'])\n    #     self.center = float(header_dic['CenterFrequency'])\n    #     self.span = float(header_dic['Span'])\n    #     self.nframes_tot = int(header_dic['ValidFrames'])\n    #     self.date_time = header_dic['DateTime']\n    #\n    #     self.nsamples_total = self.nframes_tot * fft_points\n    #     self.fs = fft_points / frame_length\n    #\n    #     # self.scale = np.sqrt(np.power(10, (gain_offset + max_input_level + level_offset) / 10) / 20 * 2)\n    #     # todo: IQ support not finished\n\n    @staticmethod\n    def read_header(str):\n\"\"\"Parses key / values from the file header\n\n        Args:\n            str (string): header string\n\n        Returns:\n            dictionary: A dictionary of key/values\n        \"\"\"        \n        dic = {}\n        for line in str:\n            name, var = line.partition(\"=\")[::2]\n            var = var.strip()\n            var = var.replace('k', 'e3')\n            var = var.replace('m', 'e-3')\n            var = var.replace('u', 'e-6')\n            # sometimes there is a string indicating day time:\n            if 'PM' not in var and 'AM' not in var:\n                var = var.replace('M', 'e6')\n            dic[name.strip()] = var\n        return dic\n</code></pre>"},{"location":"references/iqtdata/#iqtools.iqtdata.IQTData.read","title":"<code>read(nframes=10, lframes=1024, sframes=0)</code>","text":"<p>Read a section of the file.</p> <p>Parameters:</p> Name Type Description Default <code>nframes</code> <code>int</code> <p>Number of frames to be read. Defaults to 10.</p> <code>10</code> <code>lframes</code> <code>int</code> <p>Length of each frame. Defaults to 1024.</p> <code>1024</code> <code>sframes</code> <code>int</code> <p>Starting frame. Defaults to 0.</p> <code>0</code> Source code in <code>iqtools/iqtdata.py</code> <pre><code>def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n    Args:\n        nframes (int, optional): Number of frames to be read. Defaults to 10.\n        lframes (int, optional): Length of each frame. Defaults to 1024.\n        sframes (int, optional): Starting frame. Defaults to 0.\n    \"\"\"        \n    # in iqt files, lframes is always fixed 1024 at the time of reading the file.\n    # At the usage time, the lframe can be changed from time data\n\n    data_offset = 0\n    with open(self.filename, 'rb') as f:\n        ba = f.read(1)\n        data_offset += 1\n        header_size_size = int(ba.decode('utf8'))\n        ba = f.read(header_size_size)\n        data_offset += header_size_size\n        header_size = int(ba.decode('utf8'))\n        ba = f.read(header_size)\n        data_offset += header_size\n\n    self.header = ba.decode('utf8').split('\\n')\n    header_dic = self.read_header(self.header)\n\n    self.fft_points = int(header_dic['FFTPoints'])\n    self.max_input_level = float(header_dic['MaxInputLevel'])\n    self.level_offset = float(header_dic['LevelOffset'])\n    self.frame_length = float(header_dic['FrameLength'])\n    self.gain_offset = float(header_dic['GainOffset'])\n    self.center = float(header_dic['CenterFrequency'])\n    self.span = float(header_dic['Span'])\n    self.nframes_tot = int(header_dic['ValidFrames'])\n    self.date_time = header_dic['DateTime']\n\n    self.nsamples_total = self.nframes_tot * self.fft_points\n    self.fs = self.fft_points / self.frame_length\n\n    self.scale = np.sqrt(np.power(\n        10, (self.gain_offset + self.max_input_level + self.level_offset) / 10) / 20 * 2)\n\n    log.info(\"Proceeding to read binary section, 32bit (4 byte) little endian.\")\n\n    frame_header_type = np.dtype(\n        {'names': ['reserved1', 'validA', 'validP', 'validI', 'validQ', 'bins', 'reserved2', 'triggered',\n                   'overLoad', 'lastFrame', 'ticks'],\n         'formats': [np.int16, np.int16, np.int16, np.int16, np.int16, np.int16, np.int16,\n                     np.int16, np.int16, np.int16, np.int32]})\n\n    # 2 byte integer for Q, 2 byte integer for I\n    frame_data_type = np.dtype((np.int16, 2 * lframes))\n    frame_type = np.dtype({'names': ['header', 'data'],\n                           'formats': [(frame_header_type, 1), (frame_data_type, 1)]})\n\n    total_n_bytes = nframes * frame_type.itemsize\n    start_n_bytes = sframes * frame_type.itemsize\n\n    # prepare an empty array with enough room\n    self.data_array = np.zeros(lframes * nframes, np.complex64)\n\n    # Read n frames at once\n    try:\n        with open(self.filename, 'rb') as f:\n            f.seek(data_offset + start_n_bytes)\n            ba = f.read(total_n_bytes)\n    except:\n        log.error('File seems to end here!')\n        return\n\n    # print(len(ba))\n    frame_array = np.fromstring(ba, dtype=frame_type)\n\n    for i in range(frame_array.size):\n        temp_array = np.zeros(2 * lframes, np.int16)\n        temp_array[::2], temp_array[1::2] = frame_array[i]['data'][1::2], frame_array[i]['data'][::2]\n        temp_array = temp_array.astype(np.float32)\n        temp_array = temp_array.view(np.complex64)\n        self.data_array[i * lframes:(i + 1) * lframes] = temp_array\n    # and finally scale the data\n    self.data_array = self.data_array * self.scale\n</code></pre>"},{"location":"references/iqtdata/#iqtools.iqtdata.IQTData.read_header","title":"<code>read_header(str)</code>  <code>staticmethod</code>","text":"<p>Parses key / values from the file header</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <code>string</code> <p>header string</p> required <p>Returns:</p> Name Type Description <code>dictionary</code> <p>A dictionary of key/values</p> Source code in <code>iqtools/iqtdata.py</code> <pre><code>@staticmethod\ndef read_header(str):\n\"\"\"Parses key / values from the file header\n\n    Args:\n        str (string): header string\n\n    Returns:\n        dictionary: A dictionary of key/values\n    \"\"\"        \n    dic = {}\n    for line in str:\n        name, var = line.partition(\"=\")[::2]\n        var = var.strip()\n        var = var.replace('k', 'e3')\n        var = var.replace('m', 'e-3')\n        var = var.replace('u', 'e-6')\n        # sometimes there is a string indicating day time:\n        if 'PM' not in var and 'AM' not in var:\n            var = var.replace('M', 'e6')\n        dic[name.strip()] = var\n    return dic\n</code></pre>"},{"location":"references/lcdata/","title":"LCData","text":"<p>Class for reading LeCroy 584AM files</p> <p>xaratustrah@github Sep-2018</p> <p>Many thanks to github.com/nerdull for reverse engineering an old code by M. Hausmann from 1992</p>"},{"location":"references/lcdata/#iqtools.lcdata.LCData","title":"<code>LCData</code>","text":"<p>         Bases: <code>IQBase</code></p> Source code in <code>iqtools/lcdata.py</code> <pre><code>class LCData(IQBase):\n    def __init__(self, filename):\n        super().__init__(filename)\n\n        # fixed features\n        self.fs = 4e9\n        self.center = 0\n\n        # Additional fields in this subclass\n        self.date_time = time.ctime(os.path.getctime(self.filename))\n\n    def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n        Args:\n            nframes (int, optional): Number of frames to be read. Defaults to 10.\n            lframes (int, optional): Length of each frame. Defaults to 1024.\n            sframes (int, optional): Starting frame. Defaults to 0.\n        \"\"\"        \n\n        self.read_samples(nframes * lframes, offset=sframes * lframes)\n\n    def read_complete_file(self):\n\"\"\"Reads a complete file.\n\n        Returns:\n            ndarray: Returns the complete data array\n        \"\"\"        \n\n        filesize = os.path.getsize(self.filename)\n        with open(self.filename, 'rb') as f:\n            file_data = f.read()\n        # 45th byte determines the endianness\n        # one = little endian\n        biglit = ''\n        if struct.unpack_from('b', file_data, 45)[0]:\n            biglit = '&lt;'\n        else:\n            biglit = '&gt;'\n\n        hdr_len = struct.unpack_from(\n            '{}I'.format(biglit), file_data, 47)[0] + 11\n        self.nsamples_total = struct.unpack_from(\n            '{}I'.format(biglit), file_data, 71)[0]\n\n        self.vert_gain = struct.unpack_from(\n            '{}f'.format(biglit), file_data, 167)[0]\n        self.vert_offset = struct.unpack_from(\n            '{}f'.format(biglit), file_data, 171)[0]\n        self.horiz_interval = struct.unpack_from(\n            '{}f'.format(biglit), file_data, 187)[0]\n        self.horiz_offset = struct.unpack_from(\n            '{}f'.format(biglit), file_data, 191)[0]\n        self.vert_unit = struct.unpack_from('c', file_data, 207)[\n            0].decode(\"utf-8\")\n        self.horiz_unit = struct.unpack_from('c', file_data, 255)[\n            0].decode(\"utf-8\")\n\n        sec, mt, hr, dd, mm, yy = struct.unpack_from(\n            '{}dbbbbI'.format(biglit), file_data, 307)\n        try:\n            dt_obj = datetime.datetime(yy, mm, dd, hr, mt, int(\n                sec), int((sec - int(sec)) * 1e6))\n            self.date_time = dt_obj.strftime(\"%Y-%m-%d_%H:%M:%S.%f\")\n        except ValueError:\n            self.date_time = ''\n\n        self.data_array = np.frombuffer(\n            file_data, np.int8, offset=hdr_len) * self.vert_gain\n        return self.data_array\n</code></pre>"},{"location":"references/lcdata/#iqtools.lcdata.LCData.read","title":"<code>read(nframes=10, lframes=1024, sframes=0)</code>","text":"<p>Read a section of the file.</p> <p>Parameters:</p> Name Type Description Default <code>nframes</code> <code>int</code> <p>Number of frames to be read. Defaults to 10.</p> <code>10</code> <code>lframes</code> <code>int</code> <p>Length of each frame. Defaults to 1024.</p> <code>1024</code> <code>sframes</code> <code>int</code> <p>Starting frame. Defaults to 0.</p> <code>0</code> Source code in <code>iqtools/lcdata.py</code> <pre><code>def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n    Args:\n        nframes (int, optional): Number of frames to be read. Defaults to 10.\n        lframes (int, optional): Length of each frame. Defaults to 1024.\n        sframes (int, optional): Starting frame. Defaults to 0.\n    \"\"\"        \n\n    self.read_samples(nframes * lframes, offset=sframes * lframes)\n</code></pre>"},{"location":"references/lcdata/#iqtools.lcdata.LCData.read_complete_file","title":"<code>read_complete_file()</code>","text":"<p>Reads a complete file.</p> <p>Returns:</p> Name Type Description <code>ndarray</code> <p>Returns the complete data array</p> Source code in <code>iqtools/lcdata.py</code> <pre><code>def read_complete_file(self):\n\"\"\"Reads a complete file.\n\n    Returns:\n        ndarray: Returns the complete data array\n    \"\"\"        \n\n    filesize = os.path.getsize(self.filename)\n    with open(self.filename, 'rb') as f:\n        file_data = f.read()\n    # 45th byte determines the endianness\n    # one = little endian\n    biglit = ''\n    if struct.unpack_from('b', file_data, 45)[0]:\n        biglit = '&lt;'\n    else:\n        biglit = '&gt;'\n\n    hdr_len = struct.unpack_from(\n        '{}I'.format(biglit), file_data, 47)[0] + 11\n    self.nsamples_total = struct.unpack_from(\n        '{}I'.format(biglit), file_data, 71)[0]\n\n    self.vert_gain = struct.unpack_from(\n        '{}f'.format(biglit), file_data, 167)[0]\n    self.vert_offset = struct.unpack_from(\n        '{}f'.format(biglit), file_data, 171)[0]\n    self.horiz_interval = struct.unpack_from(\n        '{}f'.format(biglit), file_data, 187)[0]\n    self.horiz_offset = struct.unpack_from(\n        '{}f'.format(biglit), file_data, 191)[0]\n    self.vert_unit = struct.unpack_from('c', file_data, 207)[\n        0].decode(\"utf-8\")\n    self.horiz_unit = struct.unpack_from('c', file_data, 255)[\n        0].decode(\"utf-8\")\n\n    sec, mt, hr, dd, mm, yy = struct.unpack_from(\n        '{}dbbbbI'.format(biglit), file_data, 307)\n    try:\n        dt_obj = datetime.datetime(yy, mm, dd, hr, mt, int(\n            sec), int((sec - int(sec)) * 1e6))\n        self.date_time = dt_obj.strftime(\"%Y-%m-%d_%H:%M:%S.%f\")\n    except ValueError:\n        self.date_time = ''\n\n    self.data_array = np.frombuffer(\n        file_data, np.int8, offset=hdr_len) * self.vert_gain\n    return self.data_array\n</code></pre>"},{"location":"references/plotters/","title":"Plotters","text":"<p>Collection of plotters</p> <p>xaratustrah@github 2017</p>"},{"location":"references/plotters/#iqtools.plotters.plot_frame_power","title":"<code>plot_frame_power(yy, frame_power)</code>","text":"<p>Plot frame power, i.e. trapezoid along each time frame</p> <p>Parameters:</p> Name Type Description Default <code>yy</code> <code>ndarray</code> <p>Time meshgrid</p> required <code>frame_power</code> <code>ndarray</code> <p>Array describing the frame power</p> required Source code in <code>iqtools/plotters.py</code> <pre><code>def plot_frame_power(yy, frame_power):\n\"\"\"Plot frame power, i.e. trapezoid along each time frame\n\n    Args:\n        yy (ndarray): Time meshgrid\n        frame_power (ndarray): Array describing the frame power\n    \"\"\"    \n    plt.plot(yy[:, 0], IQBase.get_dbm(frame_power))\n    plt.ylabel('Power [dBm]')\n    plt.xlabel('Time [sec]')\n    plt.title('Frame power')\n</code></pre>"},{"location":"references/plotters/#iqtools.plotters.plot_hilbert","title":"<code>plot_hilbert(x_bar)</code>","text":"<p>Shows the Hilbert plot</p> <p>Parameters:</p> Name Type Description Default <code>x_bar</code> <code>ndarray</code> <p>Complex valued data array</p> required Source code in <code>iqtools/plotters.py</code> <pre><code>def plot_hilbert(x_bar):\n\"\"\"Shows the Hilbert plot\n\n    Args:\n        x_bar (ndarray): Complex valued data array\n    \"\"\"    \n\n    plt.plot(np.real(x_bar), np.imag(x_bar))\n    plt.grid(True)\n    plt.xlabel('Real Part')\n    plt.ylabel('Imag. Part')\n</code></pre>"},{"location":"references/plotters/#iqtools.plotters.plot_phase_shift","title":"<code>plot_phase_shift(x, phase)</code>","text":"<p>Plots the signal before and after the phase shift</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Data array</p> required <code>phase</code> <code>float</code> <p>Phase shift</p> required Source code in <code>iqtools/plotters.py</code> <pre><code>def plot_phase_shift(x, phase):\n\"\"\"Plots the signal before and after the phase shift\n\n    Args:\n        x (ndarray): Data array\n        phase (float): Phase shift\n    \"\"\"    \n    plt.rcParams['axes.grid'] = True\n    fig, axs = plt.subplots(2, 2, sharex=True, sharey=True)\n    axs[0, 0].plot(np.real(x))\n    axs[0, 1].plot(np.imag(x))\n    axs[1, 0].plot(np.real(shift_phase(x, phase)))\n    axs[1, 1].plot(np.imag(shift_phase(x, phase)))\n</code></pre>"},{"location":"references/plotters/#iqtools.plotters.plot_spectrogram","title":"<code>plot_spectrogram(xx, yy, zz, cen=0.0, cmap=cm.jet, dpi=300, dbm=False, filename=None, title='Spectrogram', zzmin=0, zzmax=1000000.0, mask=False, span=None, decimal_place=2)</code>","text":"<p>Plot the calculated spectrogram</p> <p>Parameters:</p> Name Type Description Default <code>xx</code> <code>ndarray</code> <p>Frequency meshgrid</p> required <code>yy</code> <code>ndarray</code> <p>Time meshgrid</p> required <code>zz</code> <code>ndarray</code> <p>Power meshgrid</p> required <code>cen</code> <code>float</code> <p>Center frequency. Defaults to 0.0.</p> <code>0.0</code> <code>cmap</code> <code>string</code> <p>Matplotlib.colormap. Defaults to cm.jet.</p> <code>cm.jet</code> <code>dpi</code> <code>int</code> <p>Resolution for PNG output. Defaults to 300.</p> <code>300</code> <code>dbm</code> <code>bool</code> <p>Display in dBm scale. Defaults to False.</p> <code>False</code> <code>filename</code> <code>str</code> <p>File name. Defaults to None, in which case nothing will be saved to file.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title of the plot. Defaults to 'Spectrogram'.</p> <code>'Spectrogram'</code> <code>zzmin</code> <code>int</code> <p>Color contrast min. Defaults to 0.</p> <code>0</code> <code>zzmax</code> <code>int</code> <p>Color contrast max. Defaults to 1e6.</p> <code>1000000.0</code> <code>mask</code> <code>bool</code> <p>Mask out values less than this, for cleaner histograms. Defaults to False.</p> <code>False</code> <code>span</code> <code>float</code> <p>Show only a frequency window. Defaults to None.</p> <code>None</code> <code>decimal_place</code> <code>int</code> <p>Limit display of decimal places of all numbers in the plot. Defaults to 2.</p> <code>2</code> Source code in <code>iqtools/plotters.py</code> <pre><code>def plot_spectrogram(xx, yy, zz, cen=0.0, cmap=cm.jet, dpi=300, dbm=False, filename=None, title='Spectrogram', zzmin=0, zzmax=1e6, mask=False, span=None, decimal_place=2):\n\"\"\"Plot the calculated spectrogram\n\n\n    Args:\n        xx (ndarray): Frequency meshgrid\n        yy (ndarray): Time meshgrid\n        zz (ndarray): Power meshgrid\n        cen (float, optional): Center frequency. Defaults to 0.0.\n        cmap (string, optional): Matplotlib.colormap. Defaults to cm.jet.\n        dpi (int, optional): Resolution for PNG output. Defaults to 300.\n        dbm (bool, optional): Display in dBm scale. Defaults to False.\n        filename (str, optional): File name. Defaults to None, in which case nothing will be saved to file.\n        title (str, optional): Title of the plot. Defaults to 'Spectrogram'.\n        zzmin (int, optional): Color contrast min. Defaults to 0.\n        zzmax (int, optional): Color contrast max. Defaults to 1e6.\n        mask (bool, optional): Mask out values less than this, for cleaner histograms. Defaults to False.\n        span (float, optional): Show only a frequency window. Defaults to None.\n        decimal_place (int, optional): Limit display of decimal places of all numbers in the plot. Defaults to 2.\n    \"\"\"    \n    # Apply display threshold if zmin and zmax are provided, they must be different than the default values of 0 and 1e6\n    # otherwise ignore them\n\n    if zzmin &gt;= 0 and zzmax &lt;= 1e6 and zzmin &lt; zzmax:\n        zz = zz / np.max(zz) * 1e6\n        mynorm = Normalize(vmin=zzmin, vmax=zzmax)\n\n        # mask arrays for transparency in pcolormesh\n        if mask:\n            zz = np.ma.masked_less_equal(zz, zzmin)\n\n    else:\n        # pcolormesh ignores if norm is None\n        mynorm = None\n\n    if dbm:\n        zz = IQBase.get_dbm(zz)\n\n    # here comes span in [Hz]\n    if not span:\n        spanmask = (xx[0, :] != 0) | (xx[0, :] == 0)\n    else:\n        spanmask = (xx[0, :] &lt;= span / 2) &amp; (xx[0, :] &gt;= -span / 2)\n\n    sp = plt.pcolormesh(xx[:, spanmask], yy[:, spanmask],\n                        zz[:, spanmask], cmap=cmap, norm=mynorm, shading='auto')\n    cb = plt.colorbar(sp, format=f'%.{decimal_place}e')\n\n    ax = plt.gca()\n    ax.xaxis.set_major_formatter(FormatStrFormatter(f'%.{decimal_place}e'))\n\n    delta_f = np.abs(np.abs(xx[0, 1]) - np.abs(xx[0, 0]))\n    delta_t = np.abs(np.abs(yy[1, 0]) - np.abs(yy[0, 0]))\n\n    plt.xlabel(\n        \"Delta f [Hz] @ {} (resolution = {})\".format(get_eng_notation(cen, unit='Hz', decimal_place=decimal_place), get_eng_notation(delta_f, unit='Hz', decimal_place=decimal_place)))\n    plt.ylabel('Time [sec] (resolution = {})'.format(\n        get_eng_notation(delta_t, 's', decimal_place=decimal_place)))\n    plt.title(title)\n\n    if dbm:\n        cb.set_label('Power Spectral Density a.u. [dBm/Hz]')\n    else:\n        cb.set_label('Power Spectral Density a.u.')\n\n    if filename is not None:\n        plt.savefig(filename + '.png', dpi=dpi, bbox_inches='tight')\n        plt.close()\n</code></pre>"},{"location":"references/plotters/#iqtools.plotters.plot_spectrogram_with_gnuplot","title":"<code>plot_spectrogram_with_gnuplot(zz)</code>","text":"<p>Plots using external instance of GNUPlot. Data is reshaped in form of a matrix for plotting. Idea based on this post on SO</p> <p>Parameters:</p> Name Type Description Default <code>zz</code> <code>ndarray</code> <p>Power meshgrid</p> required Source code in <code>iqtools/plotters.py</code> <pre><code>def plot_spectrogram_with_gnuplot(zz):\n\"\"\"Plots using external instance of [GNUPlot](http://www.gnuplot.info/). Data is reshaped in form of a matrix for plotting. Idea based on [this post on SO](https://stackoverflow.com/a/15885230/5177935)\n\n    Args:\n        zz (ndarray): Power meshgrid\n    \"\"\"    \n    temp_file = 'foo.bin'\n    with open(temp_file, 'wb') as foo:\n        for (i, j), dat in np.ndenumerate(np.rot90(zz, 3)):\n            s = struct.pack('4f', i, j, dat, dat)\n            foo.write(s)\n\n    gnuplot = subprocess.Popen(\n        ['gnuplot'], stdin=subprocess.PIPE, universal_newlines=True)\n\n    gnuplot.stdin.write(\"\"\"\n    set pm3d map;\n    unset clabel;\n    set terminal png size 1024,768;\n    set palette defined (0 0.0 0.0 0.5, \\\n                         1 0.0 0.0 1.0, \\\n                         2 0.0 0.5 1.0, \\\n                         3 0.0 1.0 1.0, \\\n                         4 0.5 1.0 0.5, \\\n                         5 1.0 1.0 0.0, \\\n                         6 1.0 0.5 0.0, \\\n                         7 1.0 0.0 0.0, \\\n                         8 0.5 0.0 0.0 );\n    \"\"\")\n    gnuplot.stdin.write(\"set output '{}.png';\".format(temp_file))\n    gnuplot.stdin.write(\n        \"splot '{}' binary record=(10,-1) format='%float' u 1:2:3:4 w pm3d;\".format(temp_file))\n</code></pre>"},{"location":"references/plotters/#iqtools.plotters.plot_spectrum","title":"<code>plot_spectrum(f, p, cen=0.0, span=None, dbm=False, filename=None, title='Spectrum')</code>","text":"<p>Plots 2D spectrum in dBm per Hz</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>ndarray</code> <p>Frequency array</p> required <code>p</code> <code>ndarray</code> <p>Power array</p> required <code>cen</code> <code>float</code> <p>Center frequency. Defaults to 0.0.</p> <code>0.0</code> <code>span</code> <code>float</code> <p>Frequency window. Defaults to None.</p> <code>None</code> <code>dbm</code> <code>bool</code> <p>Display in dBm scale. Defaults to False.</p> <code>False</code> <code>filename</code> <code>str</code> <p>File name. Defaults to None, in which case nothing will be saved to file.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title of the plot. Defaults to 'Spectrogram'.</p> <code>'Spectrum'</code> Source code in <code>iqtools/plotters.py</code> <pre><code>def plot_spectrum(f, p, cen=0.0, span=None, dbm=False, filename=None, title='Spectrum'):\n\"\"\"Plots 2D spectrum in dBm per Hz\n\n    Args:\n        f (ndarray): Frequency array\n        p (ndarray): Power array\n        cen (float, optional): Center frequency. Defaults to 0.0.\n        span (float, optional): Frequency window. Defaults to None.\n        dbm (bool, optional): Display in dBm scale. Defaults to False.\n        filename (str, optional): File name. Defaults to None, in which case nothing will be saved to file.\n        title (str, optional): Title of the plot. Defaults to 'Spectrogram'.\n    \"\"\"    \n\n    if not span:\n        spanmask = (f != 0) | (f == 0)\n    else:\n        spanmask = (f &lt;= span / 2) &amp; (f &gt;= -span / 2)\n    if dbm:\n        plt.plot(f[spanmask], IQBase.get_dbm(p[spanmask]))\n    else:\n        plt.plot(f[spanmask], p[spanmask])\n\n    ax = plt.gca()\n    ax.xaxis.set_major_formatter(FormatStrFormatter('%.0e'))\n\n    plt.xlabel(\"Delta f [Hz] @ {}\".format(get_eng_notation(cen, 'Hz')))\n    plt.title(title)\n    if dbm:\n        plt.ylabel('Power Spectral Density [dBm/Hz]')\n    else:\n        plt.ylabel('Power Spectral Density')\n\n    plt.grid(True)\n    if filename is not None:\n        plt.savefig(filename + '.png')  # , bbox_inches='tight')\n        plt.close()\n</code></pre>"},{"location":"references/r3fdata/","title":"R3Data","text":"<p>Class for R3F Data</p> <p>xaratustrah@github Jul-2022</p>"},{"location":"references/r3fdata/#iqtools.r3fdata.R3FData","title":"<code>R3FData</code>","text":"<p>         Bases: <code>IQBase</code></p> Source code in <code>iqtools/r3fdata.py</code> <pre><code>class R3FData(IQBase):\n    def __init__(self, filename):\n        super().__init__(filename)\n\n        # Additional fields in this subclass\n        self.date_time = ''\n        self.center = 0.0\n        self.acq_bw = 0.0\n\n        self.read_header()\n        self.cplx_adc_data = self.read_all_blocks()\n\n\n\n    def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n        Args:\n            nframes (int, optional): Number of frames to be read. Defaults to 10.\n            lframes (int, optional): Length of each frame. Defaults to 1024.\n            sframes (int, optional): Starting frame. Defaults to 0.\n        \"\"\"        \n        self.read_samples(nframes * lframes, offset=sframes * lframes)\n\n    def read_samples(self, nsamples, offset=0):\n\"\"\"Reads a certain number of samples\n\n        Args:\n            nsamples (int): Number of samples to read\n            offset (int, optional): Starting frame. Defaults to 0.\n        \"\"\"        \n        self.data_array = self.cplx_adc_data[offset : offset + nsamples]\n\n\n    def read_all_blocks(self):\n\"\"\"Reads all data blocks at once\n\n        Returns:\n            numpy.ndarray: Complex valued block\n        \"\"\"        \n        return self.read_blocks(self.nblocks)\n\n\n    def read_blocks(self, nblocks=1):\n\"\"\"Reads a number of data blocks. Each block contains 8178 samples each 2 bytes + an additional 28\n        byte footer making a total size of 16384, since fs is fixed to 112msps, each block will\n        be ca. 73us long\n\n        Args:\n            nblocks (int, optional): Number of blocks to read. Defaults to 1.\n\n        Returns:\n            numpy.ndarray: Complex valued block\n        \"\"\"        \n\n        adc_data = np.zeros(nblocks * 8178)\n        f = open(self.filename, 'rb')\n        f.seek(16384) # jump header\n        for ii in range(nblocks):\n            #print(ii)\n            ba = f.read(16384)\n            # 16 bit signed integer little endian\n            # since we divide 16384 by 2, then we ignore the last 14 not 28\n            adc_data[ii * 8178 : (ii+1) * 8178] = np.frombuffer(ba, dtype='&lt;i2')[:-14]\n\n        size = len(adc_data)\n        xaxis = np.linspace(0,size * 1/self.fs, size)\n        lo_i = np.sin(self.center * (2*np.pi) * xaxis)\n        lo_q = np.cos(self.center * (2*np.pi)* xaxis)\n        del(xaxis)\n        ii = adc_data * lo_i\n        qq = adc_data * lo_q\n        del(lo_i)\n        del(lo_q)\n        c = np.reshape(np.concatenate((ii, qq)), (2, -1)).T\n        result = 1j*c[...,1]; result += c[...,0]\n        return result\n\n    def read_header(self):\n\"\"\"Reads the header and sets the value in the objects.\n        \"\"\"          \n        size = os.path.getsize(self.filename)\n\n        # file size must be multiple integer of 16384\n        assert not size % 2**14\n\n        # first block is header\n        self.nblocks = int(size / 2**14) - 1\n\n        self.nsamples_total = self.nblocks * 8178\n\n        f = open(self.filename, 'rb')\n\n        f.seek(1024)\n        ref_level = np.frombuffer(f.read(8), dtype='&lt;f8')[0] # dBm\n        self.center = np.frombuffer(f.read(8), dtype='&lt;f8')[0] # Hz\n\n        f.seek(2048 + 4+ 6*4 + 8)\n        self.fs = np.frombuffer(f.read(8), dtype='&lt;f8')[0] # samples / s\n        self.acq_bw = np.frombuffer(f.read(8), dtype='&lt;f8')[0]\n        f.seek(2048 + 4 + 6*4 + 8 + 8 + 8 + 4 + 4 + 7*4 + 8 + 8 + 7* 4 + 4 + 8)\n\n        dt = np.frombuffer(f.read(7 * 4), dtype='&lt;i4')\n        self.date_time = f'{dt[0]}y{dt[1]}m{dt[2]}d{dt[3]}h{dt[4]}m{dt[5]}s{dt[6]}'\n        f.close()\n</code></pre>"},{"location":"references/r3fdata/#iqtools.r3fdata.R3FData.read","title":"<code>read(nframes=10, lframes=1024, sframes=0)</code>","text":"<p>Read a section of the file.</p> <p>Parameters:</p> Name Type Description Default <code>nframes</code> <code>int</code> <p>Number of frames to be read. Defaults to 10.</p> <code>10</code> <code>lframes</code> <code>int</code> <p>Length of each frame. Defaults to 1024.</p> <code>1024</code> <code>sframes</code> <code>int</code> <p>Starting frame. Defaults to 0.</p> <code>0</code> Source code in <code>iqtools/r3fdata.py</code> <pre><code>def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n    Args:\n        nframes (int, optional): Number of frames to be read. Defaults to 10.\n        lframes (int, optional): Length of each frame. Defaults to 1024.\n        sframes (int, optional): Starting frame. Defaults to 0.\n    \"\"\"        \n    self.read_samples(nframes * lframes, offset=sframes * lframes)\n</code></pre>"},{"location":"references/r3fdata/#iqtools.r3fdata.R3FData.read_all_blocks","title":"<code>read_all_blocks()</code>","text":"<p>Reads all data blocks at once</p> <p>Returns:</p> Type Description <p>numpy.ndarray: Complex valued block</p> Source code in <code>iqtools/r3fdata.py</code> <pre><code>def read_all_blocks(self):\n\"\"\"Reads all data blocks at once\n\n    Returns:\n        numpy.ndarray: Complex valued block\n    \"\"\"        \n    return self.read_blocks(self.nblocks)\n</code></pre>"},{"location":"references/r3fdata/#iqtools.r3fdata.R3FData.read_blocks","title":"<code>read_blocks(nblocks=1)</code>","text":"<p>Reads a number of data blocks. Each block contains 8178 samples each 2 bytes + an additional 28 byte footer making a total size of 16384, since fs is fixed to 112msps, each block will be ca. 73us long</p> <p>Parameters:</p> Name Type Description Default <code>nblocks</code> <code>int</code> <p>Number of blocks to read. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <p>numpy.ndarray: Complex valued block</p> Source code in <code>iqtools/r3fdata.py</code> <pre><code>def read_blocks(self, nblocks=1):\n\"\"\"Reads a number of data blocks. Each block contains 8178 samples each 2 bytes + an additional 28\n    byte footer making a total size of 16384, since fs is fixed to 112msps, each block will\n    be ca. 73us long\n\n    Args:\n        nblocks (int, optional): Number of blocks to read. Defaults to 1.\n\n    Returns:\n        numpy.ndarray: Complex valued block\n    \"\"\"        \n\n    adc_data = np.zeros(nblocks * 8178)\n    f = open(self.filename, 'rb')\n    f.seek(16384) # jump header\n    for ii in range(nblocks):\n        #print(ii)\n        ba = f.read(16384)\n        # 16 bit signed integer little endian\n        # since we divide 16384 by 2, then we ignore the last 14 not 28\n        adc_data[ii * 8178 : (ii+1) * 8178] = np.frombuffer(ba, dtype='&lt;i2')[:-14]\n\n    size = len(adc_data)\n    xaxis = np.linspace(0,size * 1/self.fs, size)\n    lo_i = np.sin(self.center * (2*np.pi) * xaxis)\n    lo_q = np.cos(self.center * (2*np.pi)* xaxis)\n    del(xaxis)\n    ii = adc_data * lo_i\n    qq = adc_data * lo_q\n    del(lo_i)\n    del(lo_q)\n    c = np.reshape(np.concatenate((ii, qq)), (2, -1)).T\n    result = 1j*c[...,1]; result += c[...,0]\n    return result\n</code></pre>"},{"location":"references/r3fdata/#iqtools.r3fdata.R3FData.read_header","title":"<code>read_header()</code>","text":"<p>Reads the header and sets the value in the objects.</p> Source code in <code>iqtools/r3fdata.py</code> <pre><code>def read_header(self):\n\"\"\"Reads the header and sets the value in the objects.\n    \"\"\"          \n    size = os.path.getsize(self.filename)\n\n    # file size must be multiple integer of 16384\n    assert not size % 2**14\n\n    # first block is header\n    self.nblocks = int(size / 2**14) - 1\n\n    self.nsamples_total = self.nblocks * 8178\n\n    f = open(self.filename, 'rb')\n\n    f.seek(1024)\n    ref_level = np.frombuffer(f.read(8), dtype='&lt;f8')[0] # dBm\n    self.center = np.frombuffer(f.read(8), dtype='&lt;f8')[0] # Hz\n\n    f.seek(2048 + 4+ 6*4 + 8)\n    self.fs = np.frombuffer(f.read(8), dtype='&lt;f8')[0] # samples / s\n    self.acq_bw = np.frombuffer(f.read(8), dtype='&lt;f8')[0]\n    f.seek(2048 + 4 + 6*4 + 8 + 8 + 8 + 4 + 4 + 7*4 + 8 + 8 + 7* 4 + 4 + 8)\n\n    dt = np.frombuffer(f.read(7 * 4), dtype='&lt;i4')\n    self.date_time = f'{dt[0]}y{dt[1]}m{dt[2]}d{dt[3]}h{dt[4]}m{dt[5]}s{dt[6]}'\n    f.close()\n</code></pre>"},{"location":"references/r3fdata/#iqtools.r3fdata.R3FData.read_samples","title":"<code>read_samples(nsamples, offset=0)</code>","text":"<p>Reads a certain number of samples</p> <p>Parameters:</p> Name Type Description Default <code>nsamples</code> <code>int</code> <p>Number of samples to read</p> required <code>offset</code> <code>int</code> <p>Starting frame. Defaults to 0.</p> <code>0</code> Source code in <code>iqtools/r3fdata.py</code> <pre><code>def read_samples(self, nsamples, offset=0):\n\"\"\"Reads a certain number of samples\n\n    Args:\n        nsamples (int): Number of samples to read\n        offset (int, optional): Starting frame. Defaults to 0.\n    \"\"\"        \n    self.data_array = self.cplx_adc_data[offset : offset + nsamples]\n</code></pre>"},{"location":"references/tcapdata/","title":"TCAPData","text":"<p>Class for IQ Data TCAP format</p> <p>xaratustrah@github Aug-2015</p>"},{"location":"references/tcapdata/#iqtools.tcapdata.TCAPData","title":"<code>TCAPData</code>","text":"<p>         Bases: <code>IQBase</code></p> Source code in <code>iqtools/tcapdata.py</code> <pre><code>class TCAPData(IQBase):\n    def __init__(self, filename, header_filename):\n        super().__init__(filename)\n\n        if not header_filename:\n            log.info('No TCAP header filename provided.')\n\n        self.header_filename = header_filename\n\n        # Additional fields in this subclass\n        self.tcap_scalers = None\n        self.tcap_pio = None\n\n        self.version = ''\n        self.adc_range = 0\n        self.block_count = 0\n        self.block_size = 0\n        self.frame_size = 0\n        self.decimation = 0\n        self.trigger_time = 0\n        self.segment_blocks = 0\n\n        self.fs = 10e6 / (2 ** self.decimation)  # usually fixed to 312500\n        # center is usually fixed to 1.6e5\n\n        self.read_header()\n\n    def read(self, nframes=10, lframes=1024, sframes=0):\n        self.read_samples(nframes * lframes, offset=sframes * lframes)\n\n    def read_samples(self, nsamples, offset=0):\n\"\"\"Reads TCAP data.\n\n        TCAP format information:\n\n            - Each file contains 15625 blocks equivalent of 27min 18 seconds of recording\n            - Each block is 2^17=131072 BYTES of data + 88 bytes of header\n            - Each sample is 4 bytes = 32bits (2 I + 2 Q bytes), hence each block contains\n            32768 complex valued samples\n            - Sampling frequency is 312500 sps, thus the data of a block are each 0.105s\n            worth of data and a resolution frequency of 312500 / 32768 = 9.5 Hz per block\n            - To double the frequency resolution one can take two consecutive blocks which\n            mean 4.77 Hz for two consecutive blocks which is 0.210 s of time.\n            - Either from one block or two blocks a frame can be created.\n            - An FFT is done on each frame. 10 such FFTs can be averaged to reduce noise.\n            e.g. a 2-block frame would correspond to 2.12s data.\n            - 400 such averaged groups of 10 frames can be plotted on a single spectrogram\n            - each picture of a single spectrogram would then correspond to 14m and 8 sec.\n\n        Args:\n            nsamples (int): Number of samples to read\n            offset (int, optional): Starting sample. Defaults to 0.\n        \"\"\"        \n\n        BLOCK_HEADER_SIZE = 88\n        BLOCK_DATA_SIZE = 2 ** 17\n        BLOCK_SIZE = BLOCK_HEADER_SIZE + BLOCK_DATA_SIZE\n\n        filesize = os.path.getsize(self.filename)\n        # each file contains 15625 blocks\n        if not filesize == 15625 * BLOCK_SIZE:\n            log.info(\n                \"File size does not match block sizes times total number of blocks. Aborting...\")\n            return\n\n        # read header section\n        with open(self.filename, 'rb') as f:\n            tfp = f.read(12)\n            pio = f.read(12)\n            scalers = f.read(64)\n\n        self.date_time = self.parse_tcap_tfp(tfp)\n        self.tcap_pio = pio\n        self.tcap_scalers = scalers\n\n        data_section_size = self.frame_size - BLOCK_HEADER_SIZE\n        n_iq_samples = data_section_size / 2 / 2  # two bytes for I and two bytes for Q\n        self.nsamples_total = self.segment_blocks * n_iq_samples\n\n        # 4 comes from 2 times 2 byte integer for I and Q\n        total_n_bytes = 4 * nsamples\n        start_n_bytes = 4 * offset\n\n        ba = bytearray()\n        try:\n            with open(self.filename, 'rb') as f:\n                f.seek(BLOCK_HEADER_SIZE + start_n_bytes)\n                for i in range(total_n_bytes):\n                    if not f.tell() % BLOCK_SIZE:\n                        log.info(\n                            'File pointer before jump: {}'.format(f.tell()))\n                        log.info(\n                            \"Reached end of block {}. Now skipoing header of block {}!\".format(\n                                int(f.tell() / BLOCK_SIZE),\n                                int(\n                                    f.tell() / BLOCK_SIZE) + 1))\n                        f.seek(88, 1)\n                        log.info('File pointer after jump: {}'.format(f.tell()))\n                    # using bytearray.extend is much faster than using +=\n                    ba.extend(f.read(1))\n        except:\n            log.error('File seems to end here!')\n            return\n\n        log.info('Total bytes read: {}'.format(len(ba)))\n\n        # big endian 16 bit for I and 16 bit for Q\n        self.data_array = np.frombuffer(ba, '&gt;i2')\n        self.data_array = self.data_array.astype(np.float32)\n        self.data_array = self.data_array * self.scale\n        self.data_array = self.data_array.view(np.complex64)\n\n    def read_block(self, block_no):\n\"\"\"\n        Read the specified block between 1 and 15625.\n        \"\"\"\n        BLOCK_HEADER_SIZE = 88\n        BLOCK_DATA_SIZE = 2 ** 17\n        BLOCK_SIZE = BLOCK_HEADER_SIZE + BLOCK_DATA_SIZE\n\n        try:\n            with open(self.filename, 'rb') as f:\n                f.seek((block_no - 1) * BLOCK_SIZE)\n                tfp = f.read(12)\n                pio = f.read(12)\n                scalers = f.read(64)\n                ba = f.read(131072)\n        except:\n            log.error('File seems to end here!')\n            return\n\n        self.date_time = self.parse_tcap_tfp(tfp)\n        self.tcap_pio = pio\n        self.tcap_scalers = scalers\n\n        log.info('Total bytes read: {}'.format(len(ba)))\n\n        # big endian 16 bit for I and 16 bit for Q\n        self.data_array = np.frombuffer(ba, '&gt;i2')\n        self.data_array = self.data_array.astype(np.float32)\n        self.data_array = self.data_array * self.scale\n        self.data_array = self.data_array.view(np.complex64)\n        return self.data_array\n\n    def get_frame(self, first, second):\n\"\"\"Make a frame by connecting two blocks\n\n        Args:\n            first: first frame\n            second: second frame\n\n        Returns:\n            array: Connected frames\n        \"\"\"        \n        array = np.zeros(2 * 32768, dtype=np.complex64)\n        array[0:32768] = self.read_block(first)\n        array[32768:] = self.read_block(second)\n        return array\n\n    def parse_binary_tcap_header(self, ba):\n\"\"\"Parses binary header of TCAP\n\n        Args:\n            ba (bytearray): Binary header\n        \"\"\"        \n        version = ba[0:8]\n        center_freq_np = np.fromstring(ba[8:16], dtype='&gt;f8')[0]\n        center_freq = struct.unpack('&gt;d', ba[8:16])[0]\n        adc_range = struct.unpack('&gt;d', ba[16:24])[0]\n        data_scale = struct.unpack('&gt;d', ba[24:32])[0]\n        block_count = struct.unpack('&gt;Q', ba[32:40])[0]\n        block_size = struct.unpack('&gt;I', ba[40:44])[0]\n        frame_size = struct.unpack('&gt;I', ba[44:48])[0]\n        decimation = struct.unpack('&gt;H', ba[48:50])[0]\n        config_flags = struct.unpack('&gt;H', ba[50:52])[0]\n        trigger_time = ba[500:512]\n        # self.fs = 10**7 / 2 ** decimation\n\n    def parse_tcap_tfp(self, ba):\n\"\"\"Parses the TFP Header of TCAP DAT Files. This information is coded in BCD. The\n        following table was taken form the original TCAP processing files in C.\n\n        | ** bit #      ** | ** 15 - 12       ** | ** 11 - 8        ** | ** 7 - 4         ** | ** 3 - 0         ** |\n        |------------------|---------------------|---------------------|---------------------|---------------------|\n        |  timereg[0]      |  not defined        |  not defined        |  status             |  days hundreds      |\n        |  timereg[1]      |  days tens          |  days units         |  hours tens         |  hours units        |\n        |  timereg[2]      |  minutes tens       |  minutes units      |  seconds tens       |  seconds units      |\n        |  timereg[3]      |  1E-1 seconds       |  1E-2 seconds       |  1E-3 seconds       |  1E-4 seconds       |\n        |  timereg[4]      |  1E-5 seconds       |  1E-6 seconds       |  1E-7 seconds       |  not defined        |\n\n         here we read the first 12 bytes ( 24 nibbles ) in the tfp byte array list. First 2 bytes\n         should be ignored.\n\n        Args:\n            ba (bytearray): Binary header\n\n        Returns:\n            datetime: Time stamp\n        \"\"\"        \n        tfp = list(ba)\n\n        dh = (tfp[3] &gt;&gt; 0) &amp; 0x0f\n\n        dt = (tfp[4] &gt;&gt; 4) &amp; 0x0f\n        du = (tfp[4] &gt;&gt; 0) &amp; 0x0f\n\n        ht = (tfp[5] &gt;&gt; 4) &amp; 0x0f\n        hu = (tfp[5] &gt;&gt; 0) &amp; 0x0f\n\n        mt = (tfp[6] &gt;&gt; 4) &amp; 0x0f\n        mu = (tfp[6] &gt;&gt; 0) &amp; 0x0f\n\n        st = (tfp[7] &gt;&gt; 4) &amp; 0x0f\n        su = (tfp[7] &gt;&gt; 0) &amp; 0x0f\n\n        sem1 = (tfp[8] &gt;&gt; 4) &amp; 0x0f\n        sem2 = (tfp[8] &gt;&gt; 0) &amp; 0x0f\n        sem3 = (tfp[9] &gt;&gt; 4) &amp; 0x0f\n        sem4 = (tfp[9] &gt;&gt; 0) &amp; 0x0f\n\n        sem5 = (tfp[10] &gt;&gt; 4) &amp; 0x0f\n        sem6 = (tfp[10] &gt;&gt; 0) &amp; 0x0f\n        #sem7 = (tfp[11] &gt;&gt; 4) &amp; 0x0f\n\n        year = int(self.file_basename[0:4])\n        days = int(dh * 100 + dt * 10 + du)\n        hours = int(ht * 10 + hu)\n        minutes = int(mt * 10 + mu)\n        seconds = int(st * 10 + su)\n        microseconds = int(1000 * (sem1 * 1e-1 + sem2 * 1e-2 + sem3 *\n                                   1e-3 + sem4 * 1e-4 + sem5 * 1e-5 + sem6 * 1e-6))\n        ts = datetime.datetime(year, 1, 1, hours, minutes, seconds,\n                               microseconds) + datetime.timedelta(days - 1)\n        return ts.strftime('%Y-%m-%d %H:%M:%S')\n\n    def read_header(self):\n\"\"\"Parses text header part.\n\n        Returns:\n            dictionary: Dictionary of values\n        \"\"\"        \n        dic = {}\n        with open(self.header_filename) as f:\n            for line in f:\n                name, var = line.split()\n                dic[name.strip()] = var\n        self.version = dic['version']\n        self.center = float(dic['center_freq'])\n        self.adc_range = float(dic['adc_range'])\n        self.scale = float(dic['data_scale'])\n        self.block_count = int(dic['block_count'])\n        self.block_size = int(dic['block_size'])\n        self.frame_size = int(dic['frame_size'])\n        self.decimation = int(dic['decimation'])\n        self.trigger_time = float(dic['trigger_time'])\n        self.segment_blocks = int(dic['segment_blocks'])\n        return dic\n</code></pre>"},{"location":"references/tcapdata/#iqtools.tcapdata.TCAPData.get_frame","title":"<code>get_frame(first, second)</code>","text":"<p>Make a frame by connecting two blocks</p> <p>Parameters:</p> Name Type Description Default <code>first</code> <p>first frame</p> required <code>second</code> <p>second frame</p> required <p>Returns:</p> Name Type Description <code>array</code> <p>Connected frames</p> Source code in <code>iqtools/tcapdata.py</code> <pre><code>def get_frame(self, first, second):\n\"\"\"Make a frame by connecting two blocks\n\n    Args:\n        first: first frame\n        second: second frame\n\n    Returns:\n        array: Connected frames\n    \"\"\"        \n    array = np.zeros(2 * 32768, dtype=np.complex64)\n    array[0:32768] = self.read_block(first)\n    array[32768:] = self.read_block(second)\n    return array\n</code></pre>"},{"location":"references/tcapdata/#iqtools.tcapdata.TCAPData.parse_binary_tcap_header","title":"<code>parse_binary_tcap_header(ba)</code>","text":"<p>Parses binary header of TCAP</p> <p>Parameters:</p> Name Type Description Default <code>ba</code> <code>bytearray</code> <p>Binary header</p> required Source code in <code>iqtools/tcapdata.py</code> <pre><code>def parse_binary_tcap_header(self, ba):\n\"\"\"Parses binary header of TCAP\n\n    Args:\n        ba (bytearray): Binary header\n    \"\"\"        \n    version = ba[0:8]\n    center_freq_np = np.fromstring(ba[8:16], dtype='&gt;f8')[0]\n    center_freq = struct.unpack('&gt;d', ba[8:16])[0]\n    adc_range = struct.unpack('&gt;d', ba[16:24])[0]\n    data_scale = struct.unpack('&gt;d', ba[24:32])[0]\n    block_count = struct.unpack('&gt;Q', ba[32:40])[0]\n    block_size = struct.unpack('&gt;I', ba[40:44])[0]\n    frame_size = struct.unpack('&gt;I', ba[44:48])[0]\n    decimation = struct.unpack('&gt;H', ba[48:50])[0]\n    config_flags = struct.unpack('&gt;H', ba[50:52])[0]\n    trigger_time = ba[500:512]\n</code></pre>"},{"location":"references/tcapdata/#iqtools.tcapdata.TCAPData.parse_tcap_tfp","title":"<code>parse_tcap_tfp(ba)</code>","text":"<p>Parses the TFP Header of TCAP DAT Files. This information is coded in BCD. The following table was taken form the original TCAP processing files in C.</p>  bit #        15 - 12         11 - 8          7 - 4           3 - 0          timereg[0] not defined not defined status days hundreds timereg[1] days tens days units hours tens hours units timereg[2] minutes tens minutes units seconds tens seconds units timereg[3] 1E-1 seconds 1E-2 seconds 1E-3 seconds 1E-4 seconds timereg[4] 1E-5 seconds 1E-6 seconds 1E-7 seconds not defined <p>here we read the first 12 bytes ( 24 nibbles ) in the tfp byte array list. First 2 bytes  should be ignored.</p> <p>Parameters:</p> Name Type Description Default <code>ba</code> <code>bytearray</code> <p>Binary header</p> required <p>Returns:</p> Name Type Description <code>datetime</code> <p>Time stamp</p> Source code in <code>iqtools/tcapdata.py</code> <pre><code>def parse_tcap_tfp(self, ba):\n\"\"\"Parses the TFP Header of TCAP DAT Files. This information is coded in BCD. The\n    following table was taken form the original TCAP processing files in C.\n\n    | ** bit #      ** | ** 15 - 12       ** | ** 11 - 8        ** | ** 7 - 4         ** | ** 3 - 0         ** |\n    |------------------|---------------------|---------------------|---------------------|---------------------|\n    |  timereg[0]      |  not defined        |  not defined        |  status             |  days hundreds      |\n    |  timereg[1]      |  days tens          |  days units         |  hours tens         |  hours units        |\n    |  timereg[2]      |  minutes tens       |  minutes units      |  seconds tens       |  seconds units      |\n    |  timereg[3]      |  1E-1 seconds       |  1E-2 seconds       |  1E-3 seconds       |  1E-4 seconds       |\n    |  timereg[4]      |  1E-5 seconds       |  1E-6 seconds       |  1E-7 seconds       |  not defined        |\n\n     here we read the first 12 bytes ( 24 nibbles ) in the tfp byte array list. First 2 bytes\n     should be ignored.\n\n    Args:\n        ba (bytearray): Binary header\n\n    Returns:\n        datetime: Time stamp\n    \"\"\"        \n    tfp = list(ba)\n\n    dh = (tfp[3] &gt;&gt; 0) &amp; 0x0f\n\n    dt = (tfp[4] &gt;&gt; 4) &amp; 0x0f\n    du = (tfp[4] &gt;&gt; 0) &amp; 0x0f\n\n    ht = (tfp[5] &gt;&gt; 4) &amp; 0x0f\n    hu = (tfp[5] &gt;&gt; 0) &amp; 0x0f\n\n    mt = (tfp[6] &gt;&gt; 4) &amp; 0x0f\n    mu = (tfp[6] &gt;&gt; 0) &amp; 0x0f\n\n    st = (tfp[7] &gt;&gt; 4) &amp; 0x0f\n    su = (tfp[7] &gt;&gt; 0) &amp; 0x0f\n\n    sem1 = (tfp[8] &gt;&gt; 4) &amp; 0x0f\n    sem2 = (tfp[8] &gt;&gt; 0) &amp; 0x0f\n    sem3 = (tfp[9] &gt;&gt; 4) &amp; 0x0f\n    sem4 = (tfp[9] &gt;&gt; 0) &amp; 0x0f\n\n    sem5 = (tfp[10] &gt;&gt; 4) &amp; 0x0f\n    sem6 = (tfp[10] &gt;&gt; 0) &amp; 0x0f\n    #sem7 = (tfp[11] &gt;&gt; 4) &amp; 0x0f\n\n    year = int(self.file_basename[0:4])\n    days = int(dh * 100 + dt * 10 + du)\n    hours = int(ht * 10 + hu)\n    minutes = int(mt * 10 + mu)\n    seconds = int(st * 10 + su)\n    microseconds = int(1000 * (sem1 * 1e-1 + sem2 * 1e-2 + sem3 *\n                               1e-3 + sem4 * 1e-4 + sem5 * 1e-5 + sem6 * 1e-6))\n    ts = datetime.datetime(year, 1, 1, hours, minutes, seconds,\n                           microseconds) + datetime.timedelta(days - 1)\n    return ts.strftime('%Y-%m-%d %H:%M:%S')\n</code></pre>"},{"location":"references/tcapdata/#iqtools.tcapdata.TCAPData.read_block","title":"<code>read_block(block_no)</code>","text":"<p>Read the specified block between 1 and 15625.</p> Source code in <code>iqtools/tcapdata.py</code> <pre><code>def read_block(self, block_no):\n\"\"\"\n    Read the specified block between 1 and 15625.\n    \"\"\"\n    BLOCK_HEADER_SIZE = 88\n    BLOCK_DATA_SIZE = 2 ** 17\n    BLOCK_SIZE = BLOCK_HEADER_SIZE + BLOCK_DATA_SIZE\n\n    try:\n        with open(self.filename, 'rb') as f:\n            f.seek((block_no - 1) * BLOCK_SIZE)\n            tfp = f.read(12)\n            pio = f.read(12)\n            scalers = f.read(64)\n            ba = f.read(131072)\n    except:\n        log.error('File seems to end here!')\n        return\n\n    self.date_time = self.parse_tcap_tfp(tfp)\n    self.tcap_pio = pio\n    self.tcap_scalers = scalers\n\n    log.info('Total bytes read: {}'.format(len(ba)))\n\n    # big endian 16 bit for I and 16 bit for Q\n    self.data_array = np.frombuffer(ba, '&gt;i2')\n    self.data_array = self.data_array.astype(np.float32)\n    self.data_array = self.data_array * self.scale\n    self.data_array = self.data_array.view(np.complex64)\n    return self.data_array\n</code></pre>"},{"location":"references/tcapdata/#iqtools.tcapdata.TCAPData.read_header","title":"<code>read_header()</code>","text":"<p>Parses text header part.</p> <p>Returns:</p> Name Type Description <code>dictionary</code> <p>Dictionary of values</p> Source code in <code>iqtools/tcapdata.py</code> <pre><code>def read_header(self):\n\"\"\"Parses text header part.\n\n    Returns:\n        dictionary: Dictionary of values\n    \"\"\"        \n    dic = {}\n    with open(self.header_filename) as f:\n        for line in f:\n            name, var = line.split()\n            dic[name.strip()] = var\n    self.version = dic['version']\n    self.center = float(dic['center_freq'])\n    self.adc_range = float(dic['adc_range'])\n    self.scale = float(dic['data_scale'])\n    self.block_count = int(dic['block_count'])\n    self.block_size = int(dic['block_size'])\n    self.frame_size = int(dic['frame_size'])\n    self.decimation = int(dic['decimation'])\n    self.trigger_time = float(dic['trigger_time'])\n    self.segment_blocks = int(dic['segment_blocks'])\n    return dic\n</code></pre>"},{"location":"references/tcapdata/#iqtools.tcapdata.TCAPData.read_samples","title":"<code>read_samples(nsamples, offset=0)</code>","text":"<p>Reads TCAP data.</p> TCAP format information <ul> <li>Each file contains 15625 blocks equivalent of 27min 18 seconds of recording</li> <li>Each block is 2^17=131072 BYTES of data + 88 bytes of header</li> <li>Each sample is 4 bytes = 32bits (2 I + 2 Q bytes), hence each block contains 32768 complex valued samples</li> <li>Sampling frequency is 312500 sps, thus the data of a block are each 0.105s worth of data and a resolution frequency of 312500 / 32768 = 9.5 Hz per block</li> <li>To double the frequency resolution one can take two consecutive blocks which mean 4.77 Hz for two consecutive blocks which is 0.210 s of time.</li> <li>Either from one block or two blocks a frame can be created.</li> <li>An FFT is done on each frame. 10 such FFTs can be averaged to reduce noise. e.g. a 2-block frame would correspond to 2.12s data.</li> <li>400 such averaged groups of 10 frames can be plotted on a single spectrogram</li> <li>each picture of a single spectrogram would then correspond to 14m and 8 sec.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>nsamples</code> <code>int</code> <p>Number of samples to read</p> required <code>offset</code> <code>int</code> <p>Starting sample. Defaults to 0.</p> <code>0</code> Source code in <code>iqtools/tcapdata.py</code> <pre><code>def read_samples(self, nsamples, offset=0):\n\"\"\"Reads TCAP data.\n\n    TCAP format information:\n\n        - Each file contains 15625 blocks equivalent of 27min 18 seconds of recording\n        - Each block is 2^17=131072 BYTES of data + 88 bytes of header\n        - Each sample is 4 bytes = 32bits (2 I + 2 Q bytes), hence each block contains\n        32768 complex valued samples\n        - Sampling frequency is 312500 sps, thus the data of a block are each 0.105s\n        worth of data and a resolution frequency of 312500 / 32768 = 9.5 Hz per block\n        - To double the frequency resolution one can take two consecutive blocks which\n        mean 4.77 Hz for two consecutive blocks which is 0.210 s of time.\n        - Either from one block or two blocks a frame can be created.\n        - An FFT is done on each frame. 10 such FFTs can be averaged to reduce noise.\n        e.g. a 2-block frame would correspond to 2.12s data.\n        - 400 such averaged groups of 10 frames can be plotted on a single spectrogram\n        - each picture of a single spectrogram would then correspond to 14m and 8 sec.\n\n    Args:\n        nsamples (int): Number of samples to read\n        offset (int, optional): Starting sample. Defaults to 0.\n    \"\"\"        \n\n    BLOCK_HEADER_SIZE = 88\n    BLOCK_DATA_SIZE = 2 ** 17\n    BLOCK_SIZE = BLOCK_HEADER_SIZE + BLOCK_DATA_SIZE\n\n    filesize = os.path.getsize(self.filename)\n    # each file contains 15625 blocks\n    if not filesize == 15625 * BLOCK_SIZE:\n        log.info(\n            \"File size does not match block sizes times total number of blocks. Aborting...\")\n        return\n\n    # read header section\n    with open(self.filename, 'rb') as f:\n        tfp = f.read(12)\n        pio = f.read(12)\n        scalers = f.read(64)\n\n    self.date_time = self.parse_tcap_tfp(tfp)\n    self.tcap_pio = pio\n    self.tcap_scalers = scalers\n\n    data_section_size = self.frame_size - BLOCK_HEADER_SIZE\n    n_iq_samples = data_section_size / 2 / 2  # two bytes for I and two bytes for Q\n    self.nsamples_total = self.segment_blocks * n_iq_samples\n\n    # 4 comes from 2 times 2 byte integer for I and Q\n    total_n_bytes = 4 * nsamples\n    start_n_bytes = 4 * offset\n\n    ba = bytearray()\n    try:\n        with open(self.filename, 'rb') as f:\n            f.seek(BLOCK_HEADER_SIZE + start_n_bytes)\n            for i in range(total_n_bytes):\n                if not f.tell() % BLOCK_SIZE:\n                    log.info(\n                        'File pointer before jump: {}'.format(f.tell()))\n                    log.info(\n                        \"Reached end of block {}. Now skipoing header of block {}!\".format(\n                            int(f.tell() / BLOCK_SIZE),\n                            int(\n                                f.tell() / BLOCK_SIZE) + 1))\n                    f.seek(88, 1)\n                    log.info('File pointer after jump: {}'.format(f.tell()))\n                # using bytearray.extend is much faster than using +=\n                ba.extend(f.read(1))\n    except:\n        log.error('File seems to end here!')\n        return\n\n    log.info('Total bytes read: {}'.format(len(ba)))\n\n    # big endian 16 bit for I and 16 bit for Q\n    self.data_array = np.frombuffer(ba, '&gt;i2')\n    self.data_array = self.data_array.astype(np.float32)\n    self.data_array = self.data_array * self.scale\n    self.data_array = self.data_array.view(np.complex64)\n</code></pre>"},{"location":"references/tiqdata/","title":"TIQData","text":"<p>Class for TIQ format</p> <p>xaratustrah@github Aug-2015</p>"},{"location":"references/tiqdata/#iqtools.tiqdata.TIQData","title":"<code>TIQData</code>","text":"<p>         Bases: <code>IQBase</code></p> Source code in <code>iqtools/tiqdata.py</code> <pre><code>class TIQData(IQBase):\n    def __init__(self, filename):\n        super().__init__(filename)\n\n        # Additional fields in this subclass\n        self.date_time = ''\n        self.span = 0.0\n        self.center = 0.0\n        self.acq_bw = 0.0\n        self.rf_att = 0.0\n        self.rbw = 0.0\n        self.data_offset = 0\n\n        self.header = ''\n        self.read_header()\n\n    def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n        Args:\n            nframes (int, optional): Number of frames to be read. Defaults to 10.\n            lframes (int, optional): Length of each frame. Defaults to 1024.\n            sframes (int, optional): Starting frame. Defaults to 0.\n        \"\"\"        \n\n        self.read_samples(nframes * lframes, offset=sframes * lframes)\n\n    def read_samples(self, nsamples, offset=0):\n\"\"\"Read samples.\n\n        Args:\n            nsamples (int): Number of samples to read from file\n            offset (int, optional): _description_. Defaults to 0.\n\n        Raises:\n            ValueError: Raises if the requested number of samples is larger than available\n        \"\"\" \n        if nsamples &gt; self.nsamples_total - offset:\n            raise ValueError(\n                'Requested number of samples is larger than the available {} samples.'.format(self.nsamples_total))\n\n        total_n_bytes = 8 * nsamples  # 8 comes from 2 times 4 byte integer for I and Q\n        start_n_bytes = 8 * offset\n\n        # file might have the correcct size, but the data not copied fully\n        try:\n            with open(self.filename, 'rb') as f:\n                f.seek(self.data_offset + start_n_bytes)\n                ba = f.read(total_n_bytes)\n        except:\n            log.error('File seems to end here!')\n            return\n\n        # return a numpy array of little endian 8 byte floats (known as doubles)\n        # little endian 4 byte ints.\n        self.data_array = np.fromstring(ba, dtype='&lt;i4')\n        # Scale to retrieve value in Volts. Augmented assignment does not work here!\n        self.data_array = self.data_array * self.scale\n        self.data_array = self.data_array.view(\n            dtype='c16')  # reinterpret the bytes as a 16 byte complex number, which consists of 2 doubles.\n\n        log.info(\"Output complex array has a size of {}.\".format(\n            self.data_array.size))\n        # in order to read you may use: data = x.item()['data'] or data = x[()]['data'] other wise you get 0-d error\n\n    def read_header(self):\n\"\"\"Parse TIQ header\n        The following information are extracted. Data needs to be normalized over 50 ohm.\n\n        AcquisitionBandwidth\n        Frequency\n        File name\n        Data I and Q [Unit is Volt]\n        Data Offset\n        DateTime\n        NumberSamples\n        Resolution Bandwidth\n        RFAttenuation (it is already considered in the data scaling, no need to use this value, only for info)\n        Sampling Frequency\n        Span\n        Voltage Scaling\n        \"\"\"\n\n        ba = bytearray('', encoding='UTF-8')\n        b = b''\n        with open(self.filename, 'rb') as f:\n            while b != b'\\n':\n                b = f.read(1)\n                ba.extend(b)\n\n        self.data_offset = int(ba.decode().split(\"\\\"\")[1])\n\n        with open(self.filename, 'rb') as f:\n            ba = f.read(self.data_offset)\n        self.header = ba\n        xml_tree_root = et.fromstring(ba)\n\n        self.date_time = [e.text for e in xml_tree_root.iter(\n            '*') if 'DateTime' in e.tag][0]\n        self.center = float([e.text for e in xml_tree_root.iter(\n            '*') if 'Frequency' in e.tag and 'Sampling' not in e.tag][0])\n        self.acq_bw = float([e.text for e in xml_tree_root.iter(\n            '*') if 'AcquisitionBandwidth' in e.tag][0])\n        self.nsamples_total = int(\n            [e.text for e in xml_tree_root.iter('*') if 'NumberSamples' in e.tag][0])\n        self.rf_att = float([e.text for e in xml_tree_root.iter(\n            '*') if 'RFAttenuation' in e.tag][0])\n        self.fs = float([e.text for e in xml_tree_root.iter(\n            '*') if 'SamplingFrequency' in e.tag][0])\n        self.scale = float(\n            [e.text for e in xml_tree_root.iter('*') if 'Scaling' in e.tag][0])\n\n        for elem in xml_tree_root.iter('NumericParameter'):\n            if 'name' in elem.attrib and elem.attrib['name'] == 'Span' and (elem.attrib['pid'] == 'specanrange' or elem.attrib['pid'] == 'globalrange'):\n                self.span = float(elem.find('Value').text)\n\n        self.rbw = 0.0\n        for elem in xml_tree_root.iter('NumericParameter'):\n            if 'name' in elem.attrib and elem.attrib['name'] == 'Resolution Bandwidth' and elem.attrib['pid'] == 'fmtRBW':\n                self.rbw = float(elem.find('Value').text)\n\n    def save_header(self):\n\"\"\"Saves the header byte array into a txt tile.\n        \"\"\"        \n\n        with open(self.filename_wo_ext + '.xml', 'wb') as f3:\n            f3.write(self.header)\n        log.info(\"Header saved in an xml file.\")\n</code></pre>"},{"location":"references/tiqdata/#iqtools.tiqdata.TIQData.read","title":"<code>read(nframes=10, lframes=1024, sframes=0)</code>","text":"<p>Read a section of the file.</p> <p>Parameters:</p> Name Type Description Default <code>nframes</code> <code>int</code> <p>Number of frames to be read. Defaults to 10.</p> <code>10</code> <code>lframes</code> <code>int</code> <p>Length of each frame. Defaults to 1024.</p> <code>1024</code> <code>sframes</code> <code>int</code> <p>Starting frame. Defaults to 0.</p> <code>0</code> Source code in <code>iqtools/tiqdata.py</code> <pre><code>def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n    Args:\n        nframes (int, optional): Number of frames to be read. Defaults to 10.\n        lframes (int, optional): Length of each frame. Defaults to 1024.\n        sframes (int, optional): Starting frame. Defaults to 0.\n    \"\"\"        \n\n    self.read_samples(nframes * lframes, offset=sframes * lframes)\n</code></pre>"},{"location":"references/tiqdata/#iqtools.tiqdata.TIQData.read_header","title":"<code>read_header()</code>","text":"<p>Parse TIQ header The following information are extracted. Data needs to be normalized over 50 ohm.</p> <p>AcquisitionBandwidth Frequency File name Data I and Q [Unit is Volt] Data Offset DateTime NumberSamples Resolution Bandwidth RFAttenuation (it is already considered in the data scaling, no need to use this value, only for info) Sampling Frequency Span Voltage Scaling</p> Source code in <code>iqtools/tiqdata.py</code> <pre><code>def read_header(self):\n\"\"\"Parse TIQ header\n    The following information are extracted. Data needs to be normalized over 50 ohm.\n\n    AcquisitionBandwidth\n    Frequency\n    File name\n    Data I and Q [Unit is Volt]\n    Data Offset\n    DateTime\n    NumberSamples\n    Resolution Bandwidth\n    RFAttenuation (it is already considered in the data scaling, no need to use this value, only for info)\n    Sampling Frequency\n    Span\n    Voltage Scaling\n    \"\"\"\n\n    ba = bytearray('', encoding='UTF-8')\n    b = b''\n    with open(self.filename, 'rb') as f:\n        while b != b'\\n':\n            b = f.read(1)\n            ba.extend(b)\n\n    self.data_offset = int(ba.decode().split(\"\\\"\")[1])\n\n    with open(self.filename, 'rb') as f:\n        ba = f.read(self.data_offset)\n    self.header = ba\n    xml_tree_root = et.fromstring(ba)\n\n    self.date_time = [e.text for e in xml_tree_root.iter(\n        '*') if 'DateTime' in e.tag][0]\n    self.center = float([e.text for e in xml_tree_root.iter(\n        '*') if 'Frequency' in e.tag and 'Sampling' not in e.tag][0])\n    self.acq_bw = float([e.text for e in xml_tree_root.iter(\n        '*') if 'AcquisitionBandwidth' in e.tag][0])\n    self.nsamples_total = int(\n        [e.text for e in xml_tree_root.iter('*') if 'NumberSamples' in e.tag][0])\n    self.rf_att = float([e.text for e in xml_tree_root.iter(\n        '*') if 'RFAttenuation' in e.tag][0])\n    self.fs = float([e.text for e in xml_tree_root.iter(\n        '*') if 'SamplingFrequency' in e.tag][0])\n    self.scale = float(\n        [e.text for e in xml_tree_root.iter('*') if 'Scaling' in e.tag][0])\n\n    for elem in xml_tree_root.iter('NumericParameter'):\n        if 'name' in elem.attrib and elem.attrib['name'] == 'Span' and (elem.attrib['pid'] == 'specanrange' or elem.attrib['pid'] == 'globalrange'):\n            self.span = float(elem.find('Value').text)\n\n    self.rbw = 0.0\n    for elem in xml_tree_root.iter('NumericParameter'):\n        if 'name' in elem.attrib and elem.attrib['name'] == 'Resolution Bandwidth' and elem.attrib['pid'] == 'fmtRBW':\n            self.rbw = float(elem.find('Value').text)\n</code></pre>"},{"location":"references/tiqdata/#iqtools.tiqdata.TIQData.read_samples","title":"<code>read_samples(nsamples, offset=0)</code>","text":"<p>Read samples.</p> <p>Parameters:</p> Name Type Description Default <code>nsamples</code> <code>int</code> <p>Number of samples to read from file</p> required <code>offset</code> <code>int</code> <p>description. Defaults to 0.</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Raises if the requested number of samples is larger than available</p> Source code in <code>iqtools/tiqdata.py</code> <pre><code>def read_samples(self, nsamples, offset=0):\n\"\"\"Read samples.\n\n    Args:\n        nsamples (int): Number of samples to read from file\n        offset (int, optional): _description_. Defaults to 0.\n\n    Raises:\n        ValueError: Raises if the requested number of samples is larger than available\n    \"\"\" \n    if nsamples &gt; self.nsamples_total - offset:\n        raise ValueError(\n            'Requested number of samples is larger than the available {} samples.'.format(self.nsamples_total))\n\n    total_n_bytes = 8 * nsamples  # 8 comes from 2 times 4 byte integer for I and Q\n    start_n_bytes = 8 * offset\n\n    # file might have the correcct size, but the data not copied fully\n    try:\n        with open(self.filename, 'rb') as f:\n            f.seek(self.data_offset + start_n_bytes)\n            ba = f.read(total_n_bytes)\n    except:\n        log.error('File seems to end here!')\n        return\n\n    # return a numpy array of little endian 8 byte floats (known as doubles)\n    # little endian 4 byte ints.\n    self.data_array = np.fromstring(ba, dtype='&lt;i4')\n    # Scale to retrieve value in Volts. Augmented assignment does not work here!\n    self.data_array = self.data_array * self.scale\n    self.data_array = self.data_array.view(\n        dtype='c16')  # reinterpret the bytes as a 16 byte complex number, which consists of 2 doubles.\n\n    log.info(\"Output complex array has a size of {}.\".format(\n        self.data_array.size))\n</code></pre>"},{"location":"references/tiqdata/#iqtools.tiqdata.TIQData.save_header","title":"<code>save_header()</code>","text":"<p>Saves the header byte array into a txt tile.</p> Source code in <code>iqtools/tiqdata.py</code> <pre><code>def save_header(self):\n\"\"\"Saves the header byte array into a txt tile.\n    \"\"\"        \n\n    with open(self.filename_wo_ext + '.xml', 'wb') as f3:\n        f3.write(self.header)\n    log.info(\"Header saved in an xml file.\")\n</code></pre>"},{"location":"references/tools/","title":"Tools","text":"<p>Collection of tools for the iqtools library</p> <p>xaratustrah@github 2017</p>"},{"location":"references/tools/#iqtools.tools.get_averaged_spectrogram","title":"<code>get_averaged_spectrogram(xa, ya, za, every)</code>","text":"<p>Averages a spectrogram in time, given every such frames in n_time_frames example:</p> <ul> <li>a spectrogram with 100 frames in time each 1024 bins in frequency will be averaged every 5 frames in time bin by bin, resulting in a new spectrogram with only 20 frames and same frame length as original.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>xx</code> <code>ndarray</code> <p>Frequency meshgrid</p> required <code>yy</code> <code>ndarray</code> <p>Time meshgrid</p> required <code>zz</code> <code>ndarray</code> <p>Power meshgrid</p> required <code>every</code> <code>int</code> <p>Averaging step</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of meshgrids</p> Source code in <code>iqtools/tools.py</code> <pre><code>def get_averaged_spectrogram(xa, ya, za, every):\n\"\"\"Averages a spectrogram in time, given every such frames in n_time_frames\n    example:\n\n    * a spectrogram with 100 frames in time each 1024 bins in frequency will be averaged every 5 frames in time bin by bin, resulting in a new spectrogram\n    with only 20 frames and same frame length as original.\n\n    Args:\n        xx (ndarray): Frequency meshgrid\n        yy (ndarray): Time meshgrid\n        zz (ndarray): Power meshgrid\n        every (int): Averaging step\n\n    Returns:\n        (tuple): Tuple of meshgrids\n\n    \"\"\"    \n    rows, cols = np.shape(za)\n    dim3 = int(rows / every)\n\n    # This is such an ndarray gymnastics I think I would never be\n    # able to figure out ever again how I managed it,\n    # but it works fine!\n\n    zz = np.reshape(za, (dim3, every, cols))\n    zz = np.average(zz, axis=1)\n\n    yy = np.reshape(ya, (dim3, every, cols))\n    yy = np.reshape(yy[:, every - 1, :].flatten(), (dim3, cols))\n\n    return xa[:dim3], yy, zz\n</code></pre>"},{"location":"references/tools/#iqtools.tools.get_concat_spectrogram","title":"<code>get_concat_spectrogram(x1, y1, z1, x2, y2, z2, delta_y=None)</code>","text":"<p>Concatenate two spectrograms</p> <p>Parameters:</p> Name Type Description Default <code>x1</code> <code>ndarray</code> <p>Frequency meshgrid</p> required <code>y1</code> <code>ndarray</code> <p>Time meshgrid</p> required <code>z1</code> <code>ndarray</code> <p>Power meshgrid</p> required <code>x2</code> <code>ndarray</code> <p>Frequency meshgrid</p> required <code>y2</code> <code>ndarray</code> <p>Time meshgrid</p> required <code>z2</code> <code>ndarray</code> <p>Power meshgrid</p> required <code>delta_y</code> <code>int</code> <p>Start offset. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of meshgrids</p> Source code in <code>iqtools/tools.py</code> <pre><code>def get_concat_spectrogram(x1, y1, z1, x2, y2, z2, delta_y=None):\n\"\"\"Concatenate two spectrograms\n\n    Args:\n        x1 (ndarray): Frequency meshgrid\n        y1 (ndarray): Time meshgrid\n        z1 (ndarray): Power meshgrid\n        x2 (ndarray): Frequency meshgrid\n        y2 (ndarray): Time meshgrid\n        z2 (ndarray): Power meshgrid\n        delta_y (int, optional): Start offset. Defaults to None.\n\n    Returns:\n        (tuple): Tuple of meshgrids\n    \"\"\"    \n    if not delta_y:\n        delta_y = y1[-1, 0] - y1[0, 0]\n    return np.concatenate((x1, x2), axis=0), np.concatenate((y1, y2 + delta_y), axis=0), np.concatenate((z1, z2), axis=0)\n</code></pre>"},{"location":"references/tools/#iqtools.tools.get_cooled_spectrogram","title":"<code>get_cooled_spectrogram(xx, yy, zz, yy_idx, fill_with=0)</code>","text":"<p>Software cool the spectrogram. Shifts rows to match the maximum of the selected time frame. After cooling / shifting, the frequency axis will have useless information. so it is left as just numbers.</p> <p>Parameters:</p> Name Type Description Default <code>xx</code> <code>ndarray</code> <p>Frequency meshgrid</p> required <code>yy</code> <code>ndarray</code> <p>Time meshgrid</p> required <code>zz</code> <code>ndarray</code> <p>Power meshgrid</p> required <code>yy_idx</code> <code>int</code> <p>Selected time frame for searching the maximum</p> required <code>fill_with</code> <code>int</code> <p>Fill with this instead of zeros. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of meshgrids</p> Source code in <code>iqtools/tools.py</code> <pre><code>def get_cooled_spectrogram(xx, yy, zz, yy_idx, fill_with=0):\n\"\"\"Software cool the spectrogram. Shifts rows to match the maximum of the selected time frame.\n    After cooling / shifting, the frequency axis will have useless information. so it is left as just numbers.\n\n    Args:\n        xx (ndarray): Frequency meshgrid\n        yy (ndarray): Time meshgrid\n        zz (ndarray): Power meshgrid\n        yy_idx (int): Selected time frame for searching the maximum\n        fill_with (int, optional): Fill with this instead of zeros. Defaults to 0.\n\n    Returns:\n        (tuple): Tuple of meshgrids\n    \"\"\"    \n\n    # make sure fill_with does not exceed the maximum in the row\n\n    b = np.argmax(zz[yy_idx])\n    z = np.ones((np.shape(zz)[0],b)) * fill_with\n    w = np.concatenate((zz.T, z.T)).T\n    newarr = np.zeros(np.shape(w))\n    ii = 0\n    # calculate distance and subtract in each row\n    for row in w:\n        diff =np.argmax(row) - b \n        newarr[ii] = np.roll(row, - diff)\n        ii+=1\n\n    xc, yc = np.meshgrid(np.arange(np.shape(newarr)[1]), np.arange(np.shape(newarr)[0]))\n    # use the same time axis\n    delta_y = yy[1][0] - yy[0][0]\n\n    # \n\n    return xc, yc * delta_y, newarr    \n</code></pre>"},{"location":"references/tools/#iqtools.tools.get_cplx_spectrogram","title":"<code>get_cplx_spectrogram(x, nframes, lframes)</code>","text":"<p>Make a 2D FFT of complex valued data array</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Data array</p> required <code>nframes</code> <code>int</code> <p>Number of frames.</p> required <code>lframes</code> <code>int</code> <p>Length of each frame.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Power meshgrid</p> Source code in <code>iqtools/tools.py</code> <pre><code>def get_cplx_spectrogram(x, nframes, lframes):\n\"\"\"Make a 2D FFT of complex valued data array\n\n    Args:\n        x (ndarray): Data array\n        nframes (int, optional): Number of frames.\n        lframes (int, optional): Length of each frame.\n\n    Returns:\n        (ndarray): Power meshgrid\n    \"\"\"    \n    sig = np.reshape(x, (nframes, lframes))\n    zz = np.fft.fft(sig, axis=1)\n    return zz\n</code></pre>"},{"location":"references/tools/#iqtools.tools.get_cut_spectrogram","title":"<code>get_cut_spectrogram(xx, yy, zz, xcen=None, xspan=None, ycen=None, yspan=None, invert=False)</code>","text":"<p>Show a section of the spectrogram. Here a section will be shown, either positive or negative, but a new meshgrid will be created. the positive version, i.e. invert = False, is similar to the get_zoomed_spectrogram functions with the difference that the mesh will be created anew.</p> <p>Parameters:</p> Name Type Description Default <code>xx</code> <code>ndarray</code> <p>Frequency meshgrid</p> required <code>yy</code> <code>ndarray</code> <p>Time meshgrid</p> required <code>zz</code> <code>ndarray</code> <p>Power meshgrid</p> required <code>xcen</code> <code>_type_</code> <p>Center in frequency. Defaults to None.</p> <code>None</code> <code>xspan</code> <code>_type_</code> <p>Frequency window. Defaults to None.</p> <code>None</code> <code>ycen</code> <code>_type_</code> <p>Center in time. Defaults to None.</p> <code>None</code> <code>yspan</code> <code>_type_</code> <p>Time window. Defaults to None.</p> <code>None</code> <code>invert</code> <code>bool</code> <p>Inverted section. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of meshgrids</p> Source code in <code>iqtools/tools.py</code> <pre><code>def get_cut_spectrogram(xx, yy, zz, xcen=None, xspan=None, ycen=None, yspan=None, invert=False):\n\"\"\"Show a section of the spectrogram.\n    Here a section will be shown, either positive or negative, but a new meshgrid will be created.\n    the positive version, i.e. invert = False, is similar to the get_zoomed_spectrogram functions\n    with the difference that the mesh will be created anew.\n\n    Args:\n        xx (ndarray): Frequency meshgrid\n        yy (ndarray): Time meshgrid\n        zz (ndarray): Power meshgrid\n        xcen (_type_, optional): Center in frequency. Defaults to None.\n        xspan (_type_, optional): Frequency window. Defaults to None.\n        ycen (_type_, optional): Center in time. Defaults to None.\n        yspan (_type_, optional): Time window. Defaults to None.\n        invert (bool, optional): Inverted section. Defaults to False.\n\n    Returns:\n        (tuple): Tuple of meshgrids\n    \"\"\"    \n\n    if not xspan:\n        xspanmask = (xx[0, :] != 0) | (xx[0, :] == 0)\n    else:\n        xspanmask = (xx[0, :] &lt;= xcen + xspan /\n                     2) &amp; (xx[0, :] &gt;= xcen - xspan / 2)\n\n    if not yspan:\n        yspanmask = (yy[:, 0] != 0) | (yy[:, 0] == 0)\n    else:\n        yspanmask = (yy[:, 0] &lt;= ycen + yspan /\n                     2) &amp; (yy[:, 0] &gt;= ycen - yspan / 2)\n\n    if invert:\n        xspanmask = np.invert(xspanmask)\n        yspanmask = np.invert(yspanmask)\n\n    # for clarification: this is how to use to masks after each other\n    newz = zz[yspanmask][:, xspanmask]\n\n    # need to create a new meshgrid due to cut, otherwise new data won't fit old mesh\n    newx, newy = np.meshgrid(\n        np.arange(np.shape(newz)[1]), np.arange(np.shape(newz)[0]))\n\n    if np.shape(yy)[0] == 1:\n        delta_y = 0\n    else:\n        delta_y = yy[1, 0] - yy[0, 0]\n    newy = newy * delta_y\n    delta_x = xx[0, 1] - xx[0, 0]\n    newx = newx - newx[-1, -1] / 2\n    newx = newx * delta_x\n\n    return newx, newy, newz\n</code></pre>"},{"location":"references/tools/#iqtools.tools.get_eng_notation","title":"<code>get_eng_notation(value, unit='', decimal_place=2)</code>","text":"<p>Convert numbers to scientific notation</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>_type_</code> <p>Input numher float or integer</p> required <code>unit</code> <code>str</code> <p>String showing the unit. Defaults to ''.</p> <code>''</code> <code>decimal_place</code> <code>int</code> <p>How many decimal places should be left</p> <code>2</code> <p>unit The unit will be shown, otherwise powers of ten. Defaults to 2.</p> <p>Returns:</p> Type Description <code>string</code> <p>Formatted string of engineering notation</p> Source code in <code>iqtools/tools.py</code> <pre><code>def get_eng_notation(value, unit='', decimal_place=2):\n\"\"\"Convert numbers to scientific notation\n\n    Args:\n        value (_type_): Input numher float or integer\n        unit (str, optional): String showing the unit. Defaults to ''.\n        decimal_place (int, optional): How many decimal places should be left\n    unit The unit will be shown, otherwise powers of ten. Defaults to 2.\n\n    Returns:\n        (string): Formatted string of engineering notation\n    \"\"\"    \n    ref = {24: 'Y', 21: 'Z', 18: 'E', 15: 'P',\n           12: 'T', 9: 'G', 6: 'M', 3: 'k', 0: '',\n           -3: 'm', -6: 'u', -9: 'n', -12: 'p',\n           -15: 'f', -18: 'a', -21: 'z', -24: 'y',\n           }\n    if value == 0:\n        return '{}{}'.format(0, unit)\n    flag = '-' if value &lt; 0 else ''\n    num = max([key for key in ref.keys() if abs(value) &gt;= 10 ** key])\n    if num == 0:\n        mult = ''\n    else:\n        mult = ref[num] if unit else 'e{}'.format(num)\n    return '{}{}{}{}'.format(flag, int(abs(value) / 10 ** num * 10 ** decimal_place) / 10 ** decimal_place, mult,\n                             unit)\n</code></pre>"},{"location":"references/tools/#iqtools.tools.get_inv_cplx_spectrogram","title":"<code>get_inv_cplx_spectrogram(zz, nframes, lframes)</code>","text":"<p>Make an inverse 2D FFT of complex valued data array</p> <p>Parameters:</p> Name Type Description Default <code>zz</code> <code>ndarray</code> <p>Power meshgrid</p> required <code>nframes</code> <code>int</code> <p>Number of frames.</p> required <code>lframes</code> <code>int</code> <p>Length of each frame.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Data array</p> Source code in <code>iqtools/tools.py</code> <pre><code>def get_inv_cplx_spectrogram(zz, nframes, lframes):\n\"\"\"Make an inverse 2D FFT of complex valued data array\n\n    Args:\n        zz (ndarray): Power meshgrid\n        nframes (int, optional): Number of frames.\n        lframes (int, optional): Length of each frame.\n\n    Returns:\n        (ndarray): Data array\n    \"\"\"    \n\n    inv_zz = np.fft.ifft(zz, axis=1)\n    inv_zz = np.reshape(inv_zz, (1, nframes * lframes))[0]\n    return inv_zz\n</code></pre>"},{"location":"references/tools/#iqtools.tools.get_iq_object","title":"<code>get_iq_object(filename, header_filename=None)</code>","text":"<p>Return suitable object accorting to extension.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>File name</p> required <code>header_filename</code> <code>str</code> <p>Name of header file. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>iqbase</code> <p>A derivative of a the iqbase class</p> Source code in <code>iqtools/tools.py</code> <pre><code>def get_iq_object(filename, header_filename=None):\n\"\"\"Return suitable object accorting to extension.\n\n    Args:\n        filename (str): File name\n        header_filename (str, optional): Name of header file. Defaults to None.\n\n    Returns:\n        (iqbase): A derivative of a the iqbase class\n    \"\"\"    \n    _, file_extension = os.path.splitext(filename)\n\n    iq_data = None\n\n    if file_extension.lower() == '.txt' or file_extension.lower() == '.csv':\n        log.info('This is an ASCII file.')\n        iq_data = CSVData(filename)\n\n    if file_extension.lower() == '.bin':\n        log.info('This is a raw binary file.')\n        iq_data = BINData(filename)\n\n    if file_extension.lower() == '.wav':\n        log.info('This is a wav file.')\n        iq_data = WAVData(filename)\n\n    if file_extension.lower() == '.iqt':\n        log.info('This is an iqt file.')\n        iq_data = IQTData(filename)\n\n    if file_extension.lower() == '.iq':\n        log.info('This is an iq file.')\n        iq_data = IQTData(filename)\n\n    if file_extension.lower() == '.tiq':\n        log.info('This is a tiq file.')\n        iq_data = TIQData(filename)\n\n    if file_extension.lower() == '.tdms':\n        log.info('This is a TDMS file.')\n        iq_data = TDMSData(filename)\n\n    if file_extension.lower() == '.r3f':\n        log.info('This is a R3F file.')\n        iq_data = R3FData(filename)\n\n    if file_extension.lower() == '.dat':\n        log.info('This is a TCAP file.')\n        if not header_filename:\n            log.info('TCAP files need a text header file as well. Aborting....')\n            return None\n        else:\n            iq_data = TCAPData(filename, header_filename)\n\n    if file_extension.lower() == '.xdat':\n        log.info('This is a XDAT file.')\n        if not header_filename:\n            log.info('XDAT files need a text header file as well. Aborting....')\n            return None\n        else:\n            iq_data = XDATData(filename, header_filename)\n\n    return iq_data\n</code></pre>"},{"location":"references/tools/#iqtools.tools.get_root_th2d","title":"<code>get_root_th2d(xx, yy, zz, name='', title='')</code>","text":"<p>Convert spectrpgram to CERN ROOT TH2 Object</p> <p>Parameters:</p> Name Type Description Default <code>xx</code> <code>ndarray</code> <p>Frequency meshgrid</p> required <code>yy</code> <code>ndarray</code> <p>Time meshgrid</p> required <code>zz</code> <code>ndarray</code> <p>Power meshgrid</p> required <code>name</code> <code>str</code> <p>Name of TH object. Defaults to ''.</p> <code>''</code> <code>title</code> <code>str</code> <p>Title of TH object. Defaults to ''.</p> <code>''</code> <p>Returns:</p> Type Description <code>TH-object</code> <p>ROOT Histogram</p> Source code in <code>iqtools/tools.py</code> <pre><code>def get_root_th2d(xx, yy, zz, name='', title=''):\n\"\"\"Convert spectrpgram to CERN ROOT TH2 Object\n\n    Args:\n        xx (ndarray): Frequency meshgrid\n        yy (ndarray): Time meshgrid\n        zz (ndarray): Power meshgrid\n        name (str, optional): Name of TH object. Defaults to ''.\n        title (str, optional): Title of TH object. Defaults to ''.\n\n    Returns:\n        (TH-object): ROOT Histogram\n    \"\"\"    \n    from ROOT import TH2D\n    h = TH2D(name, title, np.shape(xx)[\n             1], xx[0, 0], xx[0, -1], np.shape(yy)[0], yy[0, 0], yy[-1, 0])\n    for j in range(np.shape(yy)[0]):\n        for i in range(np.shape(xx)[1]):\n            h.SetBinContent(i, j, zz[j, i])\n    return h\n</code></pre>"},{"location":"references/tools/#iqtools.tools.get_zoomed_spectrogram","title":"<code>get_zoomed_spectrogram(xx, yy, zz, xcen=None, xspan=None, ycen=None, yspan=None)</code>","text":"<p>Zoom into a section of the spectrogram</p> <p>Parameters:</p> Name Type Description Default <code>xx</code> <code>ndarray</code> <p>Frequency meshgrid</p> required <code>yy</code> <code>ndarray</code> <p>Time meshgrid</p> required <code>zz</code> <code>ndarray</code> <p>Power meshgrid</p> required <code>xcen</code> <code>_type_</code> <p>Center in frequency. Defaults to None.</p> <code>None</code> <code>xspan</code> <code>_type_</code> <p>Frequency window. Defaults to None.</p> <code>None</code> <code>ycen</code> <code>_type_</code> <p>Center in time. Defaults to None.</p> <code>None</code> <code>yspan</code> <code>_type_</code> <p>Time window. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of meshgrids</p> Source code in <code>iqtools/tools.py</code> <pre><code>def get_zoomed_spectrogram(xx, yy, zz, xcen=None, xspan=None, ycen=None, yspan=None):\n\"\"\"Zoom into a section of the spectrogram\n\n    Args:\n        xx (ndarray): Frequency meshgrid\n        yy (ndarray): Time meshgrid\n        zz (ndarray): Power meshgrid\n        xcen (_type_, optional): Center in frequency. Defaults to None.\n        xspan (_type_, optional): Frequency window. Defaults to None.\n        ycen (_type_, optional): Center in time. Defaults to None.\n        yspan (_type_, optional): Time window. Defaults to None.\n\n    Returns:\n        (tuple): Tuple of meshgrids\n    \"\"\"    \n\n    if not xspan:\n        xspanmask = (xx[0, :] != 0) | (xx[0, :] == 0)\n    else:\n        xspanmask = (xx[0, :] &lt;= xcen + xspan /\n                     2) &amp; (xx[0, :] &gt;= xcen - xspan / 2)\n\n    if not yspan:\n        yspanmask = (yy[:, 0] != 0) | (yy[:, 0] == 0)\n    else:\n        yspanmask = (yy[:, 0] &lt;= ycen + yspan /\n                     2) &amp; (yy[:, 0] &gt;= ycen - yspan / 2)\n\n    # based on https://github.com/numpy/numpy/issues/13255#issuecomment-479529731\n    return xx[yspanmask][:, xspanmask], yy[yspanmask][:, xspanmask], zz[yspanmask][:, xspanmask]\n</code></pre>"},{"location":"references/tools/#iqtools.tools.make_analytical","title":"<code>make_analytical(x)</code>","text":"<p>Makes an analytical signal using Hilbert transformation</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Real valued data array</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Complex valued data array</p> Source code in <code>iqtools/tools.py</code> <pre><code>def make_analytical(x):\n\"\"\"Makes an analytical signal using Hilbert transformation\n\n    Args:\n        x (ndarray): Real valued data array\n\n    Returns:\n        (ndarray): Complex valued data array\n    \"\"\"    \n\n    yy = hilbert(x)\n    ii = np.real(yy)\n    qq = np.imag(yy)\n    x_bar = np.vectorize(complex)(ii, qq)\n    ins_ph = np.angle(x_bar) * 180 / np.pi\n    return x_bar, ins_ph\n</code></pre>"},{"location":"references/tools/#iqtools.tools.make_test_signal","title":"<code>make_test_signal(f, fs, length=1, nharm=0, noise=False)</code>","text":"<p>Make a sine signal with/without noise.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>float</code> <p>Desired signal frequency</p> required <code>fs</code> <code>float</code> <p>Desired sampling frequency</p> required <code>length</code> <code>int</code> <p>Length in seconds. Defaults to 1.</p> <code>1</code> <code>nharm</code> <code>int</code> <p>No. of harmonics. Defaults to 0.</p> <code>0</code> <code>noise</code> <code>bool</code> <p>Add noise. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>tuple</code> <p>tuple of ndarrays, time and frequency</p> Source code in <code>iqtools/tools.py</code> <pre><code>def make_test_signal(f, fs, length=1, nharm=0, noise=False):\n\"\"\"Make a sine signal with/without noise.\n\n    Args:\n        f (float): Desired signal frequency\n        fs (float): Desired sampling frequency\n        length (int, optional): Length in seconds. Defaults to 1.\n        nharm (int, optional): No. of harmonics. Defaults to 0.\n        noise (bool, optional): Add noise. Defaults to False.\n\n    Returns:\n        (tuple): tuple of ndarrays, time and frequency\n    \"\"\"    \n\n    t = np.arange(0, length, 1 / fs)\n    x = np.zeros(len(t))\n    for i in range(nharm + 2):\n        x += np.sin(2 * np.pi * i * f * t)\n\n    if noise:\n        x += np.random.normal(0, 1, len(t))\n    return t, x\n</code></pre>"},{"location":"references/tools/#iqtools.tools.parse_filename","title":"<code>parse_filename(filename)</code>","text":"Parses filenames of experimental data in the following format <p>58Ni26+_374MeVu_250uA_pos_0_0.tiq</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>string</code> <p>File name</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Tuple of strings for description, energy and current</p> Source code in <code>iqtools/tools.py</code> <pre><code>def parse_filename(filename):\n\"\"\"Parses filenames of experimental data in the following format:\n\n        58Ni26+_374MeVu_250uA_pos_0_0.tiq\n\n    Args:\n        filename (string): File name\n\n    Returns:\n        (tuple): Tuple of strings for description, energy and current\n    \"\"\"    \n    filename = filename.split('_')\n    descr = filename[0]\n    energy = float(filename[1].replace('MeVu', 'e6'))\n    current = float(filename[2].replace('uA', 'e-6'))\n    return descr, energy, current\n</code></pre>"},{"location":"references/tools/#iqtools.tools.read_data_csv","title":"<code>read_data_csv(filename)</code>","text":"<p>Read special format CSV data file from RSA5100 series output. Please note that 50 ohm power termination is already considered for these data.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>string</code> <p>File name</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>ndarray of data</p> Source code in <code>iqtools/tools.py</code> <pre><code>def read_data_csv(filename):\n\"\"\"Read special format CSV data file from RSA5100 series output.\n    Please note that 50 ohm power termination is already considered\n    for these data.\n\n    Args:\n        filename (string): File name\n\n    Returns:\n        (ndarray): ndarray of data\n    \"\"\"    \n    data = np.genfromtxt(filename, skip_header=10, delimiter=\",\")\n    # has one dimension more, should use ravel\n    data = np.ravel(data).view(dtype='c16')\n    return data\n</code></pre>"},{"location":"references/tools/#iqtools.tools.read_rsa_result_csv","title":"<code>read_rsa_result_csv(filename)</code>","text":"<p>Read special format CSV result file from RSA5000 series output</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>string</code> <p>File name</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Arrays of frequency and power</p> Source code in <code>iqtools/tools.py</code> <pre><code>def read_rsa_result_csv(filename):\n\"\"\"Read special format CSV result file from RSA5000 series output\n\n    Args:\n        filename (string): File name\n\n    Returns:\n        (tuple): Arrays of frequency and power\n    \"\"\"    \n    p = np.genfromtxt(filename, skip_header=63)\n    with open(filename) as f:\n        cont = f.readlines()\n    for l in cont:\n        l = l.split(',')\n        if 'Frequency' in l and len(l) == 3:\n            center = float(l[1])\n        if 'XStart' in l and len(l) == 3:\n            start = float(l[1])\n        if 'XStop' in l and len(l) == 3:\n            stop = float(l[1])\n    f = np.linspace(start - center, stop - center, len(p))\n    return f, p\n</code></pre>"},{"location":"references/tools/#iqtools.tools.read_rsa_specan_xml","title":"<code>read_rsa_specan_xml(filename)</code>","text":"<p>Read the resulting saved trace file Specan from the Tektronix RSA5000 series these files are produced while saving traces.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>string</code> <p>File name</p> required <p>Returns:</p> Type Description <code>tuple</code> <p>Arrays of frequency, power, and values of units</p> Source code in <code>iqtools/tools.py</code> <pre><code>def read_rsa_specan_xml(filename):\n\"\"\"Read the resulting saved trace file Specan from the Tektronix RSA5000 series\n    these files are produced while saving traces.\n\n    Args:\n        filename (string): File name\n\n    Returns:\n        (tuple): Arrays of frequency, power, and values of units\n    \"\"\"    \n    with open(filename, 'rb') as f:\n        ba = f.read()\n    xml_tree_root = et.fromstring(ba)\n    for elem in xml_tree_root.iter(tag='Count'):\n        count = int(elem.text)\n    for elem in xml_tree_root.iter(tag='XStart'):\n        start = float(elem.text)\n    for elem in xml_tree_root.iter(tag='XStop'):\n        stop = float(elem.text)\n    for elem in xml_tree_root.iter(tag='XUnits'):\n        xunits = elem.text\n    for elem in xml_tree_root.iter(tag='YUnits'):\n        yunits = elem.text\n    for elem in xml_tree_root.iter(tag='y'):\n        pwr = float(elem.text)\n    p = np.zeros(count)\n    i = 0\n    for elem in xml_tree_root.iter(tag='y'):\n        p[i] = float(elem.text)\n        i += 1\n    f = np.linspace(start, stop, count)\n\n    return f, p, (xunits, yunits)\n</code></pre>"},{"location":"references/tools/#iqtools.tools.remove_plot_content_from_spectrogram_svg","title":"<code>remove_plot_content_from_spectrogram_svg(input_filename, output_filename)</code>","text":"<p>Removes plot content from an existing SVG file. This function is specifically useful if you like to have an empty spectrogram plot for publication purposes.</p> <p>Parameters:</p> Name Type Description Default <code>input_filename</code> <code>string</code> <p>Input file name</p> required <code>output_filename</code> <code>string</code> <p>Output file name</p> required Source code in <code>iqtools/tools.py</code> <pre><code>def remove_plot_content_from_spectrogram_svg(input_filename, output_filename):\n\"\"\"Removes plot content from an existing SVG file. This function is specifically useful if you like to have an empty spectrogram plot for publication purposes.\n\n    Args:\n        input_filename (string): Input file name\n        output_filename (string): Output file name\n    \"\"\"    \n    soup = BeautifulSoup(open(input_filename).read(),features=\"xml\")\n    for element in soup.find_all('g', {\"id\" : \"QuadMesh_1\"}):\n        element.decompose()\n    with open(output_filename, \"w\") as file:\n        file.write(str(soup))\n</code></pre>"},{"location":"references/tools/#iqtools.tools.shift_phase","title":"<code>shift_phase(x, phase)</code>","text":"<p>Shift phase in frequency domain</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p>Complex or analytical signal</p> required <code>phase</code> <code>ndarray</code> <p>Desired phase shift</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Shifted complex signal</p> Source code in <code>iqtools/tools.py</code> <pre><code>def shift_phase(x, phase):\n\"\"\"Shift phase in frequency domain\n\n    Args:\n        x (ndarray): Complex or analytical signal\n        phase (ndarray): Desired phase shift\n\n    Returns:\n        (ndarray): Shifted complex signal\n    \"\"\"    \n    XX = np.fft.fft(x)\n    angle = np.unwrap(np.angle(XX)) + phase\n    YY = np.abs(XX) * np.exp(1j * angle)\n    return np.fft.ifft(YY)\n</code></pre>"},{"location":"references/tools/#iqtools.tools.write_signal_to_bin","title":"<code>write_signal_to_bin(cx, filename, fs=1, center=0, write_header=True)</code>","text":"<p>Write complex valued signal to raw binary file If write header is set to true, then the first 4 bytes of the file are 32-bit sampling Frequency and then follows the center frequency also in 32-bit. the Data follows afterwards in I, Q format each 32-bit as well.</p> <p>Parameters:</p> Name Type Description Default <code>cx</code> <code>ndarray</code> <p>Complex valued data array</p> required <code>filename</code> <code>string</code> <p>File name</p> required <code>fs</code> <code>int</code> <p>Sampling frequency. Defaults to 1.</p> <code>1</code> <code>center</code> <code>int</code> <p>Center frequency. Defaults to 0.</p> <code>0</code> <code>write_header</code> <code>bool</code> <p>Whether the header should be written or not. Defaults to True.</p> <code>True</code> Source code in <code>iqtools/tools.py</code> <pre><code>def write_signal_to_bin(cx, filename, fs=1, center=0, write_header=True):\n\"\"\"Write complex valued signal to raw binary file\n    If write header is set to true, then the first 4 bytes of the file are 32-bit\n    sampling Frequency and then follows the center frequency also in 32-bit. the\n    Data follows afterwards in I, Q format each 32-bit as well.\n\n    Args:\n        cx (ndarray): Complex valued data array\n        filename (string): File name\n        fs (int, optional): Sampling frequency. Defaults to 1.\n        center (int, optional): Center frequency. Defaults to 0.\n        write_header (bool, optional): Whether the header should be written or not. Defaults to True.\n    \"\"\"    \n    # 32-bit little endian floats\n    # insert header\n    if write_header:\n        cx = np.insert(cx, 0, complex(fs, center))\n    cx = cx.astype(np.complex64)\n    cx.tofile(filename + '.bin')\n</code></pre>"},{"location":"references/tools/#iqtools.tools.write_signal_to_csv","title":"<code>write_signal_to_csv(cx, filename, fs=1, center=0)</code>","text":"<p>Write complex valued signal to CSV text file</p> <p>Parameters:</p> Name Type Description Default <code>cx</code> <code>ndarray</code> <p>Complex valued data array</p> required <code>filename</code> <code>string</code> <p>File name</p> required <code>fs</code> <code>int</code> <p>Sampling frequency. Defaults to 1.</p> <code>1</code> <code>center</code> <code>int</code> <p>Center frequency. Defaults to 0.</p> <code>0</code> Source code in <code>iqtools/tools.py</code> <pre><code>def write_signal_to_csv(cx, filename, fs=1, center=0):\n\"\"\"Write complex valued signal to CSV text file\n\n    Args:\n        cx (ndarray): Complex valued data array\n        filename (string): File name\n        fs (int, optional): Sampling frequency. Defaults to 1.\n        center (int, optional): Center frequency. Defaults to 0.\n    \"\"\"    \n    # insert ascii header which looks like a complex number\n    cx = np.insert(cx, 0, complex(fs, center))\n    with open(filename + '.csv', 'w') as f:\n        for i in range(len(cx)):\n            f.write('{}|{}\\n'.format(\n                np.real(cx[i]), np.imag(cx[i])))\n</code></pre>"},{"location":"references/tools/#iqtools.tools.write_signal_to_wav","title":"<code>write_signal_to_wav(cx, filename, fs=1)</code>","text":"<p>Write complex valued signal as audio WAV file</p> <p>Parameters:</p> Name Type Description Default <code>cx</code> <code>ndarray</code> <p>Complex valued data array</p> required <code>filename</code> <code>string</code> <p>File name</p> required <code>fs</code> <code>int</code> <p>Sampling frequency. Defaults to 1.</p> <code>1</code> Source code in <code>iqtools/tools.py</code> <pre><code>def write_signal_to_wav(cx, filename, fs=1):\n\"\"\"Write complex valued signal as audio WAV file\n\n    Args:\n        cx (ndarray): Complex valued data array\n        filename (string): File name\n        fs (int, optional): Sampling frequency. Defaults to 1.\n    \"\"\"    \n    wavfile.write(filename + '.wav', fs,\n                  abs(cx) / max(abs(cx)))\n</code></pre>"},{"location":"references/tools/#iqtools.tools.write_spectrogram_to_nifti","title":"<code>write_spectrogram_to_nifti(zz, filename)</code>","text":"<p>Writes spectrogram to a NIFTI file.</p> <p>Parameters:</p> Name Type Description Default <code>zz</code> <code>ndarray</code> <p>Power meshgrid</p> required <code>filename</code> <code>string</code> <p>File name</p> required Source code in <code>iqtools/tools.py</code> <pre><code>def write_spectrogram_to_nifti(zz, filename):\n\"\"\"Writes spectrogram to a NIFTI file.\n\n    Args:\n        zz (ndarray): Power meshgrid\n        filename (string): File name\n    \"\"\"    \n    # normalize to 1\n    b = np.expand_dims(zz, axis=2)\n    b = b/b.max()\n    img = nib.Nifti1Image(b, affine=np.eye(4))\n    nib.save(img, f'{filename}.nii.gz')\n</code></pre>"},{"location":"references/tools/#iqtools.tools.write_spectrum_to_csv","title":"<code>write_spectrum_to_csv(ff, pp, filename, center=0)</code>","text":"<p>Writes 1D spectrum to text CSV format. First column will be frequency, second linear power and third logarithmic power.</p> <p>Parameters:</p> Name Type Description Default <code>ff</code> <code>ndarray</code> <p>Frequency data array</p> required <code>pp</code> <code>ndarray</code> <p>Power data array</p> required <code>filename</code> <code>string</code> <p>Output file name</p> required <code>center</code> <code>float</code> <p>Center frequency. Defaults to 0.</p> <code>0</code> Source code in <code>iqtools/tools.py</code> <pre><code>def write_spectrum_to_csv(ff, pp, filename, center=0):\n\"\"\"Writes 1D spectrum to text CSV format. First column will be frequency, second linear power and third logarithmic power.\n\n    Args:\n        ff (ndarray): Frequency data array\n        pp (ndarray): Power data array\n        filename (string): Output file name\n        center (float, optional): Center frequency. Defaults to 0.\n    \"\"\"    \n    a = np.concatenate(\n        (ff, pp, IQBase.get_dbm(pp)))\n    b = np.reshape(a, (3, -1)).T\n    np.savetxt(filename + '.csv', b, header='Delta f [Hz] @ {:.2e} [Hz]|Power [W]|Power [dBm]'.format(\n        center), delimiter='|')\n</code></pre>"},{"location":"references/tools/#iqtools.tools.write_spectrum_to_root","title":"<code>write_spectrum_to_root(ff, pp, filename, center=0, title='')</code>","text":"<p>Write spectrum to a ROOT file using objects of TH class</p> <p>Parameters:</p> Name Type Description Default <code>ff</code> <code>ndarray</code> <p>Frequency data array</p> required <code>pp</code> <code>ndarray</code> <p>Power data array</p> required <code>filename</code> <code>string</code> <p>Output file name</p> required <code>center</code> <code>float</code> <p>Center frequency. Defaults to 0.</p> <code>0</code> <code>title</code> <code>str</code> <p>Title of ROOT histogram. Defaults to ''.</p> <code>''</code> Source code in <code>iqtools/tools.py</code> <pre><code>def write_spectrum_to_root(ff, pp, filename, center=0, title=''):\n\"\"\"Write spectrum to a ROOT file using objects of TH class\n\n    Args:\n        ff (ndarray): Frequency data array\n        pp (ndarray): Power data array\n        filename (string): Output file name\n        center (float, optional): Center frequency. Defaults to 0.\n        title (str, optional): Title of ROOT histogram. Defaults to ''.\n    \"\"\"    \n    class MyTH1(uproot3_methods.classes.TH1.Methods, list):\n        def __init__(self, low, high, values, title=\"\"):\n            self._fXaxis = types.SimpleNamespace()\n            self._fXaxis._fNbins = len(values)\n            self._fXaxis._fXmin = low\n            self._fXaxis._fXmax = high\n            values.insert(0, 0)\n            values.append(0)\n            for x in values:\n                self.append(float(x))\n            self._fTitle = title\n            self._classname = \"TH1F\"\n\n    th1f = MyTH1(center + ff[0], center + ff[-1], pp.tolist(), title=title)\n    file = uproot3.recreate(filename + '.root', compression=uproot3.ZLIB(4))\n    file[\"th1f\"] = th1f\n</code></pre>"},{"location":"references/tools/#iqtools.tools.write_timedata_to_npy","title":"<code>write_timedata_to_npy(iq_obj, filename)</code>","text":"<p>Saves the iq object to a npy format.</p> <p>Parameters:</p> Name Type Description Default <code>iq_obj</code> <code>iqbase</code> <p>iq object</p> required <code>filename</code> <code>string</code> <p>Output file name</p> required Source code in <code>iqtools/tools.py</code> <pre><code>def write_timedata_to_npy(iq_obj, filename):\n\"\"\"Saves the iq object to a npy format.\n\n    Args:\n        iq_obj (iqbase): iq object\n        filename (string): Output file name\n    \"\"\"    \n    np.save(filename + '.npy', vars(iq_obj))\n</code></pre>"},{"location":"references/tools/#iqtools.tools.write_timedata_to_root","title":"<code>write_timedata_to_root(iq_obj)</code>","text":"<p>Writes time data to a root TTree. The structure of the root files in this case is like this: there are two trees inside, one tree has only one branch with an integer in it, which is the sampling rate, and another tree with a branch which is the center frequency. the other tree also has a branch in it, which contains the time series, which correspond to the power of the signal, meaning (I^2+Q^2). The distance between the time samples is 1/(sampling_rate).</p> <p>Parameters:</p> Name Type Description Default <code>iq_obj</code> <code>iqbase</code> <p>iq object</p> required Source code in <code>iqtools/tools.py</code> <pre><code>def write_timedata_to_root(iq_obj):\n\"\"\"Writes time data to a root TTree.\n    The structure of the root files in this case is like this: there are two\n    trees inside, one tree has only one branch with an integer in it, which\n    is the sampling rate, and another tree with a branch which is the center\n    frequency. the other tree also has a branch in it, which contains the time\n    series, which correspond to the power of the signal, meaning **(I^2+Q^2)**.\n    The distance between the time samples is **1/(sampling_rate)**.\n\n    Args:\n        iq_obj (iqbase): iq object\n    \"\"\"    \n\n    with uproot3.recreate(iq_obj.filename_wo_ext + '.root') as f:\n        f['t_f_samp'] = uproot3.newtree(\n            {'f_samp': uproot3.newbranch(np.int32, title='Sampling frequency'),\n             })\n        f['t_f_center'] = uproot3.newtree(\n            {'f_center': uproot3.newbranch(np.int32, title='Center frequency'),\n             })\n        f['t_timedata'] = uproot3.newtree(\n            {'timedata': uproot3.newbranch(np.float64, title='Time domain signal power')})\n\n        f['t_f_samp'].extend({'f_samp': np.array([int(iq_obj.fs)])})\n        f['t_f_center'].extend({'f_center': np.array([int(iq_obj.center)])})\n\n        f['t_timedata'].extend({'timedata': np.abs(iq_obj.data_array)**2})\n</code></pre>"},{"location":"references/wavdata/","title":"WAVData","text":"<p>Class for IQ Data WAV formats</p> <p>xaratustrah@github Aug-2015</p>"},{"location":"references/wavdata/#iqtools.wavdata.WAVData","title":"<code>WAVData</code>","text":"<p>         Bases: <code>IQBase</code></p> Source code in <code>iqtools/wavdata.py</code> <pre><code>class WAVData(IQBase):\n    def __init__(self, filename):\n        super().__init__(filename)\n\n        # Additional fields in this subclass\n        self.date_time = time.ctime(os.path.getctime(self.filename))\n\n    def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n        Args:\n            nframes (int, optional): Number of frames to be read. Defaults to 10.\n            lframes (int, optional): Length of each frame. Defaults to 1024.\n            sframes (int, optional): Starting frame. Defaults to 0.\n        \"\"\"        \n\n        self.read_samples(nframes * lframes, offset=sframes * lframes)\n\n    def read_samples(self, nsamples, offset=0):\n\"\"\"Read samples.\n\n        Args:\n            nsamples (int): Number of samples to read from file\n            offset (int, optional): _description_. Defaults to 0.\n\n        Raises:\n            ValueError: Raises if the requested number of samples is larger than available\n        \"\"\"        \n\n        # activate memory map\n        try:\n            fs, data = wavfile.read(self.filename, mmap=True)\n        except:\n            log.error('File seems to end here!')\n            return\n        all_data = data.astype(np.complex64)\n        self.fs = fs\n        self.center = 0\n        self.nsamples_total = len(all_data)\n\n        if nsamples &gt; self.nsamples_total - offset:\n            raise ValueError(\n                'Requested number of samples is larger than the available {} samples.'.format(self.nsamples_total))\n\n        self.data_array = all_data[offset:nsamples + offset]\n</code></pre>"},{"location":"references/wavdata/#iqtools.wavdata.WAVData.read","title":"<code>read(nframes=10, lframes=1024, sframes=0)</code>","text":"<p>Read a section of the file.</p> <p>Parameters:</p> Name Type Description Default <code>nframes</code> <code>int</code> <p>Number of frames to be read. Defaults to 10.</p> <code>10</code> <code>lframes</code> <code>int</code> <p>Length of each frame. Defaults to 1024.</p> <code>1024</code> <code>sframes</code> <code>int</code> <p>Starting frame. Defaults to 0.</p> <code>0</code> Source code in <code>iqtools/wavdata.py</code> <pre><code>def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n    Args:\n        nframes (int, optional): Number of frames to be read. Defaults to 10.\n        lframes (int, optional): Length of each frame. Defaults to 1024.\n        sframes (int, optional): Starting frame. Defaults to 0.\n    \"\"\"        \n\n    self.read_samples(nframes * lframes, offset=sframes * lframes)\n</code></pre>"},{"location":"references/wavdata/#iqtools.wavdata.WAVData.read_samples","title":"<code>read_samples(nsamples, offset=0)</code>","text":"<p>Read samples.</p> <p>Parameters:</p> Name Type Description Default <code>nsamples</code> <code>int</code> <p>Number of samples to read from file</p> required <code>offset</code> <code>int</code> <p>description. Defaults to 0.</p> <code>0</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Raises if the requested number of samples is larger than available</p> Source code in <code>iqtools/wavdata.py</code> <pre><code>def read_samples(self, nsamples, offset=0):\n\"\"\"Read samples.\n\n    Args:\n        nsamples (int): Number of samples to read from file\n        offset (int, optional): _description_. Defaults to 0.\n\n    Raises:\n        ValueError: Raises if the requested number of samples is larger than available\n    \"\"\"        \n\n    # activate memory map\n    try:\n        fs, data = wavfile.read(self.filename, mmap=True)\n    except:\n        log.error('File seems to end here!')\n        return\n    all_data = data.astype(np.complex64)\n    self.fs = fs\n    self.center = 0\n    self.nsamples_total = len(all_data)\n\n    if nsamples &gt; self.nsamples_total - offset:\n        raise ValueError(\n            'Requested number of samples is larger than the available {} samples.'.format(self.nsamples_total))\n\n    self.data_array = all_data[offset:nsamples + offset]\n</code></pre>"},{"location":"references/xdatdata/","title":"XDATData","text":"<p>Class for IQ Data Tektronix (TM) X-COM XDATData</p> <p>xaratustrah@github Juli 2020</p>"},{"location":"references/xdatdata/#iqtools.xdatdata.XDATData","title":"<code>XDATData</code>","text":"<p>         Bases: <code>IQBase</code></p> Source code in <code>iqtools/xdatdata.py</code> <pre><code>class XDATData(IQBase):\n    def __init__(self, filename, header_filename):\n        super().__init__(filename)\n\n        # Additional fields in this subclass\n        self.center = 0\n        self.acq_bw = 0\n        self.date_time = ''\n\n        self.header_filename = header_filename\n        self.read_header()\n\n    def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n        Args:\n            nframes (int, optional): Number of frames to be read. Defaults to 10.\n            lframes (int, optional): Length of each frame. Defaults to 1024.\n            sframes (int, optional): Starting frame. Defaults to 0.\n        \"\"\"        \n\n        self.read_samples(nframes * lframes, offset=sframes * lframes)\n\n    def read_samples(self, nsamples, offset=0):\n\"\"\"Read samples. The X-COM XDAT format can be described as a 16 integer interlaced\n        I &amp; Q file. I and Q are each a 16 bit little endian integer. I &amp; Q are interlaced \n        together in a single file or memory buffer with order being I,Q.\n\n        Args:\n            nsamples (int): Number of samples to read from file\n            offset (int, optional): _description_. Defaults to 0.\n\n        \"\"\"        \n        filesize = os.path.getsize(self.filename)\n        # each file contains 15625 blocks\n        if not filesize == 4 * self.nsamples_total:\n            raise ValueError(\n                \"File size does not match total number of samples. Aborting...\")\n\n        if nsamples &gt; self.nsamples_total - offset:\n            raise ValueError(\n                'Requested number of samples is larger than the available {} samples.'.format(self.nsamples_total))\n\n        total_n_bytes = 8 * nsamples  # 8 comes from 2 times 4 byte integer for I and Q\n        start_n_bytes = 8 * offset\n\n        try:\n            with open(self.filename, 'rb') as f:\n                f.seek(start_n_bytes)\n                ba = f.read(total_n_bytes)\n        except Exception as e:\n            log.error(e + 'File seems to end here!')\n            return\n\n        # return a numpy array of little endian 8 byte floats (known as doubles)\n        # little endian 4 byte ints.\n        self.data_array = np.fromstring(ba, dtype='&lt;i4')\n        # Scale to retrieve value in Volts. Augmented assignment does not work here!\n        self.data_array = self.data_array * self.scale\n        self.data_array = self.data_array.view(\n            dtype='c16')  # reinterpret the bytes as a 16 byte complex number, which consists of 2 doubles.\n\n        log.info(\"Output complex array has a size of {}.\".format(\n            self.data_array.size))\n        # in order to read you may use: data = x.item()['data'] or data = x[()]['data'] other wise you get 0-d error\n\n    def read_header(self):\n\"\"\"Parse XDAT header file\n        \"\"\"        \n        tree = et.parse(self.header_filename)\n        root = tree.getroot()\n        for feature in root.iter('recording'):\n            self.center = float(feature.get('center_frequency'))\n            self.scale = float(feature.get('acq_scale_factor'))\n            self.acq_bw = float(feature.get('acquisition_bandwidth'))\n            self.fs = float(feature.get('sample_rate'))\n            self.date_time = feature.get('creation_time')\n\n        for feature in root.iter('data'):\n            self.nsamples_total = int(feature.get('samples'))\n</code></pre>"},{"location":"references/xdatdata/#iqtools.xdatdata.XDATData.read","title":"<code>read(nframes=10, lframes=1024, sframes=0)</code>","text":"<p>Read a section of the file.</p> <p>Parameters:</p> Name Type Description Default <code>nframes</code> <code>int</code> <p>Number of frames to be read. Defaults to 10.</p> <code>10</code> <code>lframes</code> <code>int</code> <p>Length of each frame. Defaults to 1024.</p> <code>1024</code> <code>sframes</code> <code>int</code> <p>Starting frame. Defaults to 0.</p> <code>0</code> Source code in <code>iqtools/xdatdata.py</code> <pre><code>def read(self, nframes=10, lframes=1024, sframes=0):\n\"\"\"Read a section of the file.\n\n    Args:\n        nframes (int, optional): Number of frames to be read. Defaults to 10.\n        lframes (int, optional): Length of each frame. Defaults to 1024.\n        sframes (int, optional): Starting frame. Defaults to 0.\n    \"\"\"        \n\n    self.read_samples(nframes * lframes, offset=sframes * lframes)\n</code></pre>"},{"location":"references/xdatdata/#iqtools.xdatdata.XDATData.read_header","title":"<code>read_header()</code>","text":"<p>Parse XDAT header file</p> Source code in <code>iqtools/xdatdata.py</code> <pre><code>def read_header(self):\n\"\"\"Parse XDAT header file\n    \"\"\"        \n    tree = et.parse(self.header_filename)\n    root = tree.getroot()\n    for feature in root.iter('recording'):\n        self.center = float(feature.get('center_frequency'))\n        self.scale = float(feature.get('acq_scale_factor'))\n        self.acq_bw = float(feature.get('acquisition_bandwidth'))\n        self.fs = float(feature.get('sample_rate'))\n        self.date_time = feature.get('creation_time')\n\n    for feature in root.iter('data'):\n        self.nsamples_total = int(feature.get('samples'))\n</code></pre>"},{"location":"references/xdatdata/#iqtools.xdatdata.XDATData.read_samples","title":"<code>read_samples(nsamples, offset=0)</code>","text":"<p>Read samples. The X-COM XDAT format can be described as a 16 integer interlaced I &amp; Q file. I and Q are each a 16 bit little endian integer. I &amp; Q are interlaced  together in a single file or memory buffer with order being I,Q.</p> <p>Parameters:</p> Name Type Description Default <code>nsamples</code> <code>int</code> <p>Number of samples to read from file</p> required <code>offset</code> <code>int</code> <p>description. Defaults to 0.</p> <code>0</code> Source code in <code>iqtools/xdatdata.py</code> <pre><code>def read_samples(self, nsamples, offset=0):\n\"\"\"Read samples. The X-COM XDAT format can be described as a 16 integer interlaced\n    I &amp; Q file. I and Q are each a 16 bit little endian integer. I &amp; Q are interlaced \n    together in a single file or memory buffer with order being I,Q.\n\n    Args:\n        nsamples (int): Number of samples to read from file\n        offset (int, optional): _description_. Defaults to 0.\n\n    \"\"\"        \n    filesize = os.path.getsize(self.filename)\n    # each file contains 15625 blocks\n    if not filesize == 4 * self.nsamples_total:\n        raise ValueError(\n            \"File size does not match total number of samples. Aborting...\")\n\n    if nsamples &gt; self.nsamples_total - offset:\n        raise ValueError(\n            'Requested number of samples is larger than the available {} samples.'.format(self.nsamples_total))\n\n    total_n_bytes = 8 * nsamples  # 8 comes from 2 times 4 byte integer for I and Q\n    start_n_bytes = 8 * offset\n\n    try:\n        with open(self.filename, 'rb') as f:\n            f.seek(start_n_bytes)\n            ba = f.read(total_n_bytes)\n    except Exception as e:\n        log.error(e + 'File seems to end here!')\n        return\n\n    # return a numpy array of little endian 8 byte floats (known as doubles)\n    # little endian 4 byte ints.\n    self.data_array = np.fromstring(ba, dtype='&lt;i4')\n    # Scale to retrieve value in Volts. Augmented assignment does not work here!\n    self.data_array = self.data_array * self.scale\n    self.data_array = self.data_array.view(\n        dtype='c16')  # reinterpret the bytes as a 16 byte complex number, which consists of 2 doubles.\n\n    log.info(\"Output complex array has a size of {}.\".format(\n        self.data_array.size))\n</code></pre>"}]}